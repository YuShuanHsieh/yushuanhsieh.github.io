<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>COSCUP on Cherie's Tech Blog</title><link>https://yushuanhsieh.github.io/categories/coscup/</link><description>Recent content in COSCUP on Cherie's Tech Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 04 Aug 2020 08:00:00 +0800</lastBuildDate><atom:link href="https://yushuanhsieh.github.io/categories/coscup/index.xml" rel="self" type="application/rss+xml"/><item><title>COSCUP 2020 - Goroutine stack and local variable allocation in Go</title><link>https://yushuanhsieh.github.io/posts/2020-08-04-coscup-go/</link><pubDate>Tue, 04 Aug 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-08-04-coscup-go/</guid><description>&lt;h2 id="qa-補充"&gt;Q&amp;amp;A 補充&lt;/h2&gt;
&lt;p&gt;Slides: &lt;a href="https://www.slideshare.net/CherrieHsieh/goroutine-stack-and-local-variable-allocation-in-go"&gt;Goroutine stack and local variable allocation in Go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這次分享中，有人詢問我在 stack growing 的時候， user stack 和 system stack 是如何交替切換的。由於當時沒有仔細看 switch 流程，無法很清楚地答覆他，所以事後又看了一下這段，並且畫出簡圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://yushuanhsieh.github.io/posts/coscup-go_2.png" alt="hugo"&gt;&lt;/p&gt;
&lt;p&gt;首先，在 curg (current goroutine) func1 呼叫 func2 後，發現 user stack 空間不足，此時先儲存 func1 的 state 到 M 的 morebuf struct 中（用來 bug tracing），接著把 func2 的 state （就是當前 goroutine 的執行狀態，包含 stack pointer, program counter 等）存在 curg 的 sched struct 中，接著 switch 到 g0，從 g0 的 sched 取出 stack pointer 的值 (system stack) 並且設定，接著就可以執行 newstack function。&lt;/p&gt;</description></item></channel></rss>