<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Cherie's Tech Blog</title><link>https://yushuanhsieh.github.io/categories/go/</link><description>Recent content in Go on Cherie's Tech Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 08 Mar 2024 08:00:00 +0800</lastBuildDate><atom:link href="https://yushuanhsieh.github.io/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>從 Golang 1.22 routing enhancement 看專案開發</title><link>https://yushuanhsieh.github.io/posts/2024-03-09-golang_routing/</link><pubDate>Fri, 08 Mar 2024 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2024-03-09-golang_routing/</guid><description>&lt;p&gt;這次 Golang 1.22 版本針對內建的 http.ServeMux (HTTP request multiplexer) 進行改善，原本 http.ServeMux 的設計力求直覺單純，適用在架設簡單 HTTP server 的應用場景；但隨著 RESTful API 成為目前 HTTP-based interface 設計主流，而既有的 http.ServeMux 並沒有辦法實作 RESTful API，導致內建的 http.ServeMux 使用時機愈來愈少，Gopher 必須仰賴第三方套件才能實現 RESTful API。為了改善此問題，Golang 1.22 加強了 http.ServeMux 的 routing 設計，除了能夠辨別 HTTP method 之外，也增加了動態路徑 wildcard 的功能，使 http.ServeMux 能夠滿足實務上基本 HTTP server 的需求。&lt;/p&gt;</description></item><item><title>The issue of uploading a large-size file using HTTP formdata</title><link>https://yushuanhsieh.github.io/posts/2024-02-18-file_uploading/</link><pubDate>Sat, 17 Feb 2024 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2024-02-18-file_uploading/</guid><description>&lt;p&gt;接續&lt;a href="https://yushuanhsieh.github.io/post/2024-01-27-python_fastapi_formdata/"&gt;前面文章&lt;/a&gt;提及到，在上傳檔案的使用情境之下，因為 user request 數量增多，造成 service lead time 大幅提升的問題；而導致 lead time 增加的因素，根據實驗數據，主要是因為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The different implementation methods of receiving the file&lt;/li&gt;
&lt;li&gt;The concurrency model of language runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若要從根本來改善此問題，需要從兩個層面來著手：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client side: user 如何傳送夾帶檔案內容的 request 到 server&lt;/li&gt;
&lt;li&gt;Server side: server 如何依據 client 發送 request 的流程來處理此檔案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;透過使用者訪談後，我們預期的使用情境，包含：&lt;/p&gt;</description></item><item><title>Python FastAPI FormData 效能議題</title><link>https://yushuanhsieh.github.io/posts/2024-01-27-python_fastapi_formdata/</link><pubDate>Fri, 26 Jan 2024 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2024-01-27-python_fastapi_formdata/</guid><description>&lt;p&gt;在實作檔案上傳並加解密的服務時，遇到了 user request 數量增多，造成 lead time 大幅提升的問題。服務本身是使用 Python + FastAPI framework 實作，在排除了網路頻寬問題和 server 效能問題後，懷疑是 Python 或 framework 導致延遲時間拉長，所以就決定從此地方著手進行 benchmark 實驗，來觀察瓶頸是發生在何處。&lt;/p&gt;
&lt;p&gt;由於最終目的還是希望能找出改善的方式，而既然認為問題是出在 Python 和 framework 上，這次實驗就會先使用 FastAPI 與 aiohttp 寫的 HTTP API service 進行效能比較；此外也使用 Golang 實作的版本來測量不同語言之間的效能落差會到多少。&lt;/p&gt;
&lt;p&gt;While implementing a file upload service with encryption and decryption, we encountered an issue where an increase in user requests significantly increased the lead time. The service is built using Python and the FastAPI framework. After ruling out network bandwidth and server performance issues, we suspect that the delay may be due to Python or the framework. Therefore, we decided to start with a benchmarking experiment in this area to identify where the bottleneck occurs.&lt;/p&gt;</description></item><item><title>Golang slice append 實作細節</title><link>https://yushuanhsieh.github.io/posts/2021-12-29-golang-slice-append/</link><pubDate>Wed, 29 Dec 2021 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2021-12-29-golang-slice-append/</guid><description>&lt;p&gt;用 Golang 刷 leetcode 題目時，如果不太清楚 Golang slice 與相關 function 的運作原理，很容易踩到坑，尤其是使用其他高階語言的開發者，剛轉換到 Golang 時會覺得為什麼同樣的程式邏輯，但是出來的結果卻不一樣。因此本篇簡單說明 Golang 最常使用到的 slice append function 運作原理，並且使用 objdump 來觀察記憶體操作狀況。&lt;/p&gt;
&lt;h2 id="slice-internal"&gt;Slice internal&lt;/h2&gt;
&lt;p&gt;首先推薦先閱讀 Golang blog &lt;a href="https://go.dev/blog/slices-intro"&gt;Go Slices: usage and internals&lt;/a&gt;，雖然距離文章發布的日期已久遠，但是 slice internal 結構還是可以參考。文中很重要的一個概念是：&lt;strong&gt;A slice is a descriptor of an array segment.&lt;/strong&gt;， 雖然我們使用 slice 方式很像 array ，但實際上 slice 是一個 descriptor struct ，其中會有一個 array pointer 指向真正存放數值的 array 中。&lt;/p&gt;</description></item><item><title>Run Go applications on Raspberry Pi Pico using TinyGo</title><link>https://yushuanhsieh.github.io/posts/2021-10-01-raspi_pico_tinygo/</link><pubDate>Fri, 01 Oct 2021 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2021-10-01-raspi_pico_tinygo/</guid><description>&lt;p&gt;&lt;a href="https://github.com/tinygo-org/tinygo"&gt;TinyGo - Go compiler for small places.&lt;/a&gt; TinyGo 自 2019 年正式公開以來，就逐漸受到關注，尤其是 Google 在 2019 年 &lt;a href="https://go.dev/blog/10years"&gt;10 years of Go&lt;/a&gt; 也有特別提到 Go 原本將目標放在網路或是雲端等應用程式，不過未來期望能夠更廣泛地應用在 microcontroller 上。在近期 TinyGo 開始支援 Raspberry Pi Pico，再加上 TinyGo 架構也逐漸成熟，因此就來試用看看。&lt;/p&gt;
&lt;h2 id="run-applications-on-raspberry-pi-pico"&gt;Run applications on Raspberry Pi Pico&lt;/h2&gt;
&lt;p&gt;在分析 TinyGo 如何編譯適合跑在 Raspberry Pi Pico 的 Go program 之前，先來複習如何讓 user application 在 Raspberry Pi Pico (以下皆簡稱為 Pico) 上執行。在 Pico 進入 user application 的 entry point 之前，會有幾個前置流程，包含：&lt;/p&gt;</description></item><item><title>Switch to a register-based calling convention for Go functions</title><link>https://yushuanhsieh.github.io/posts/2021-04-24-go-calling-convention/</link><pubDate>Sat, 24 Apr 2021 01:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2021-04-24-go-calling-convention/</guid><description>&lt;p&gt;自己對於 memory layout 相關議題都蠻感興趣的，而這次 Go 1.17 有一項效能改善的 proposal: &lt;a href="https://go.googlesource.com/proposal/+/master/design/40724-register-calling.md"&gt;&lt;strong&gt;switch to a register-based calling convention for Go functions&lt;/strong&gt;&lt;/a&gt; 剛好跟 memory 有相關，因此就看了一下 proposal 文件介紹，不但複習了在計算機架構中曾接觸到的 calling convention 知識，也對於 Go 內部機制有更多認識。&lt;/p&gt;
&lt;h3 id="application-binary-interface-abi"&gt;Application Binary Interface (ABI)&lt;/h3&gt;
&lt;p&gt;在談 calling convention 之前，先來談 ABI。Calling convention 是 &lt;a href="https://en.wikipedia.org/wiki/Application_binary_interface"&gt;application binary interface (ABI)&lt;/a&gt; 的一部分，而定義 ABI 最主要的目的是建立應用程式與其他應用程式或是與作業系統服務之間低階溝通方式 (依賴 machine code) ，讓應用程式能夠在特定的環境下正確執行。&lt;/p&gt;</description></item><item><title>GopherCon TW 2020 場務組心得</title><link>https://yushuanhsieh.github.io/posts/2020-11-14-gophercon_2020/</link><pubDate>Sat, 14 Nov 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-11-14-gophercon_2020/</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;從 2020 年初就開始籌備的第一屆 GopherCon TW ，終於在 11/14(六) 美好地落幕。第一次籌備就遇上疫情問題，導致時程一再延遲，還有首次主辦 conference 經驗不足，有一些遺漏以及沒有注意到的地方，所以自認籌辦期間沒有做的很好 TT&lt;/p&gt;
&lt;p&gt;&lt;img src="https://yushuanhsieh.github.io/posts/gophercon_2020_1.jpg" alt="vault"&gt;&lt;/p&gt;
&lt;p&gt;不得不說本次能籌辦成功，多虧總召 David 大力的主持（五星吹捧），時程安排、籌辦會議、以及細節等都處理的很好，並且非常有組織和號召力，難怪是一個好主管，非常敬佩他，希望自己也能在這部分多加油！&lt;/p&gt;
&lt;h2 id="會議規模"&gt;會議規模&lt;/h2&gt;
&lt;p&gt;預估參加人數：300 人 (比例：男 9 女 1)
議程軌： 1 主軌 / 1 天&lt;/p&gt;
&lt;h2 id="租用場地"&gt;租用場地&lt;/h2&gt;
&lt;p&gt;我們是 6 個月前預訂場地，不過有些更適合(便宜)的場地已被租出去，如果可以在 9 個月前預訂(3季的時間)會更好。&lt;/p&gt;
&lt;p&gt;另外，因為是第一屆 GopherCon，且只有一個議程軌，希望能有一個好的開場，因此場地就朝階梯式大型會議廳的方向尋找，而會議當天呈現出來的視覺感受和體驗也確實不錯，缺點是費用真的相對較高，而且能容納的人數有限，往後如果參加的人數更多，還是會找其他非階梯式的會議廳。&lt;/p&gt;
&lt;h2 id="攤位規劃"&gt;攤位規劃&lt;/h2&gt;
&lt;p&gt;在租用場地時，一定要連同攤位規劃一起討論，例如會議廳外可不可以擺設攤位，攤位的數量等。由於我們這次租用的會議廳外無法擺設太多攤位，因此我們額外租用一間較小的會議廳來設置攤位，但就當天情況來說，所有的攤位都在一間房間內，出入口又不大，所以當人多的時候就顯得很擁擠，這是我覺得後續可以改善的地方。&lt;/p&gt;
&lt;p&gt;另外，這次租用的場地，牆壁材質無法供廠商黏貼海報或其他宣傳物品，雖然可以用大頭針固定在牆上，但是會對廠商的宣傳物造成破壞，因此讓他們只好捨棄一些擺設，這也是未來租場地時要注意的地方，如果真的無法粘貼，應在攤位規劃說明書上註明清楚，才不會讓他們白帶一趟。&lt;/p&gt;
&lt;p&gt;最後，我們本來以為在走道上的攤位會有最多曝光，沒想到參加者在休息時間都往擺設飲食的區域移動，完全不理會經過的攤位 QQ 讓我重新學到食物的威力有多驚人，也很抱歉沒有讓贊助商有預期的廣宣量。&lt;/p&gt;</description></item><item><title>Vault Initialization and Keys Security</title><link>https://yushuanhsieh.github.io/posts/2020-09-04-vault-security/</link><pubDate>Fri, 04 Sep 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-09-04-vault-security/</guid><description>&lt;h2 id="預備知識"&gt;預備知識&lt;/h2&gt;
&lt;p&gt;在閱讀下方內容之前，建議先對 Vault 架構有個基本了解，相關官方文章如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.vaultproject.io/docs/internals/architecture"&gt;Vault Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.vaultproject.io/docs/internals/rotation"&gt;Vault Key Rotation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.vaultproject.io/docs/concepts/seal"&gt;Vault Seal/Unseal&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外， &lt;code&gt;Barrier&lt;/code&gt; 這個元件在 Vault 相當重要，在 &lt;a href="https://www.vaultproject.io/docs/internals/architecture"&gt;Vault Architecture&lt;/a&gt; 頁面中有提及，可以先了解其用意，再來看它是如何被實現。&lt;/p&gt;
&lt;h2 id="問題"&gt;問題&lt;/h2&gt;
&lt;p&gt;Vault 在進行 unseal 流程時，其中最重要的就是將加密過的 master key 解密，接著再利用 master key 解出 encryption Key，並且建立起 barrier 防護，讓 storage backend 的資料可以安全地來往於 Vault server 與 storage backend 之間。&lt;/p&gt;</description></item><item><title>COSCUP 2020 - Goroutine stack and local variable allocation in Go</title><link>https://yushuanhsieh.github.io/posts/2020-08-04-coscup-go/</link><pubDate>Tue, 04 Aug 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-08-04-coscup-go/</guid><description>&lt;h2 id="qa-補充"&gt;Q&amp;amp;A 補充&lt;/h2&gt;
&lt;p&gt;Slides: &lt;a href="https://www.slideshare.net/CherrieHsieh/goroutine-stack-and-local-variable-allocation-in-go"&gt;Goroutine stack and local variable allocation in Go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這次分享中，有人詢問我在 stack growing 的時候， user stack 和 system stack 是如何交替切換的。由於當時沒有仔細看 switch 流程，無法很清楚地答覆他，所以事後又看了一下這段，並且畫出簡圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://yushuanhsieh.github.io/posts/coscup-go_2.png" alt="hugo"&gt;&lt;/p&gt;
&lt;p&gt;首先，在 curg (current goroutine) func1 呼叫 func2 後，發現 user stack 空間不足，此時先儲存 func1 的 state 到 M 的 morebuf struct 中（用來 bug tracing），接著把 func2 的 state （就是當前 goroutine 的執行狀態，包含 stack pointer, program counter 等）存在 curg 的 sched struct 中，接著 switch 到 g0，從 g0 的 sched 取出 stack pointer 的值 (system stack) 並且設定，接著就可以執行 newstack function。&lt;/p&gt;</description></item><item><title>Escape analysis issues of strings builder</title><link>https://yushuanhsieh.github.io/posts/2020-06-24-strings-builder/</link><pubDate>Wed, 24 Jun 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-06-24-strings-builder/</guid><description>&lt;p&gt;在分享 &lt;a href="https://yushuanhsieh.github.io/post/2020-06-01-string-to-slice/"&gt;Go string to slice 議題&lt;/a&gt; 文章後，有朋友(感謝@陳孝思)在社團裡面分享另一個議題，關於在 strings package 的 builder 中有避免 escape analysis 的方式。基於這個分享，我就去查閱了相關 source code 和 issues ，並且整理成此文章。&lt;/p&gt;
&lt;h2 id="escape-analysis"&gt;Escape analysis&lt;/h2&gt;
&lt;p&gt;escape analysis 是協助 Go compiler 判斷要將 variable 分配在 goroutine stack 還是 heap 的方式，而由於變數的分配位置會關係到 garbage collection 進而影響效能，因此 escape analysis 也是 Gopher 所在意的議題之一。&lt;/p&gt;</description></item><item><title>Go string to slice 議題</title><link>https://yushuanhsieh.github.io/posts/2020-06-01-string-to-slice/</link><pubDate>Mon, 01 Jun 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-06-01-string-to-slice/</guid><description>&lt;p&gt;日前在看 Go runtime/string.go source code 的時候，意外看到一篇文章 &lt;a href="https://www.cnblogs.com/mushroom/p/8998538.html"&gt;Go中string转[]byte的陷阱&lt;/a&gt;，不過這篇文章的日期間隔已久，Go version 也從文章中的 1.10 改版到 1.14 了，所以想要更新一下這個議題現況。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://yushuanhsieh.github.io/posts/string-to-slice.png" alt="hugo"&gt;&lt;/p&gt;
&lt;h2 id="version"&gt;Version&lt;/h2&gt;
&lt;p&gt;Go version: 1.14&lt;/p&gt;
&lt;h2 id="問題摘要"&gt;問題摘要&lt;/h2&gt;
&lt;h3 id="1-runtimestringtoslicebyte"&gt;1. runtime.stringtoslicebyte&lt;/h3&gt;
&lt;p&gt;首先，文章中提到的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;2
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;3
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;4
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;5
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;6
&lt;/span&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;func&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#6639ba"&gt;main&lt;/span&gt;&lt;span style="color:#1f2328"&gt;()&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#1f2328"&gt;{&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#1f2328"&gt;s&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0550ae"&gt;:=&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#1f2328"&gt;[]&lt;/span&gt;&lt;span style="color:#6639ba"&gt;byte&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;)&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#1f2328"&gt;s1&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0550ae"&gt;:=&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#6639ba"&gt;append&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;s&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;)&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#1f2328"&gt;s2&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0550ae"&gt;:=&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#6639ba"&gt;append&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;s&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;)&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#57606a"&gt;//fmt.Println(s1, &amp;#34;==========&amp;#34;, s2)&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#1f2328"&gt;fmt&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#6639ba"&gt;Println&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#6639ba"&gt;string&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;s1&lt;/span&gt;&lt;span style="color:#1f2328"&gt;),&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;==========&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#6639ba"&gt;string&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;s2&lt;/span&gt;&lt;span style="color:#1f2328"&gt;))&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在沒有 &lt;code&gt;fmt.Println(s1, &amp;quot;==========&amp;quot;, s2)&lt;/code&gt; 這一行的情況下，output 會產生：&lt;/p&gt;</description></item><item><title>Side Project - Transfer.sh</title><link>https://yushuanhsieh.github.io/posts/2020-05-19-transfer.sh/</link><pubDate>Tue, 19 May 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-05-19-transfer.sh/</guid><description>&lt;p&gt;在 &lt;a href="https://yushuanhsieh.github.io/post/2020-04-15-transfer-sh-refactor/"&gt;Trace transfer.sh open project&lt;/a&gt; 有提到我目前正在調整 &lt;a href="https://github.com/dutchcoders/transfer.sh"&gt;transfer.sh&lt;/a&gt; 這個 open source project，把它修改成內部所需要的一個 service，而之前已經改得差不多了，所以簡單地來介紹一下修改了哪些內容：&lt;/p&gt;
&lt;h2 id="需求"&gt;需求&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;每個 download request 能依需求驗證 IP address 和 user account / password&lt;/li&gt;
&lt;li&gt;能使用外部 service 來驗證 user account&lt;/li&gt;
&lt;li&gt;需能支援 curl cmd tool&lt;/li&gt;
&lt;li&gt;k8s deployment&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="修改項目"&gt;修改項目&lt;/h2&gt;
&lt;h3 id="1-middleware-chain"&gt;1. Middleware Chain&lt;/h3&gt;
&lt;p&gt;根據需求 1，在 &lt;code&gt;getHandler&lt;/code&gt; 前加入 middleware chain，其中包含：&lt;/p&gt;</description></item><item><title>Side Project - Symlink Generator for Multi-lang Hugo Site</title><link>https://yushuanhsieh.github.io/posts/2020-04-29-hugo-symlinks/</link><pubDate>Wed, 29 Apr 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-04-29-hugo-symlinks/</guid><description>&lt;p&gt;在 &lt;a href="https://yushuanhsieh.github.io/post/2020-04-07-hugo-merge/"&gt;Multilingual Mode in Hugo&lt;/a&gt; 這篇文章中有提到目前使用 Hugo site generator 產生 multi-lang site 的問題，使用者必須要為每個語言都建立一個檔案，才不會造成最後在產生網站後，發生某一個語言的頁面遺失問題。（例如，使用者一定要建立 &lt;code&gt;about.md&lt;/code&gt;, &lt;code&gt;about.tw.md&lt;/code&gt;，這樣當瀏覽者在選擇中文語言的網站時，才會顯示出 about 頁面）。這樣其實會造成不少困擾，因為不是每個語言都可以這麼即時的被翻譯完成，但我們又不希望有頁面遺失，因此需要透過一些方式來解決這個問題。&lt;/p&gt;
&lt;p&gt;而其中一個方法就是建立一個 &lt;code&gt;symbolic link&lt;/code&gt;，當某個語言還沒被翻譯時，就建立一個 symbolic link 來代表這個檔案，然後實際檔案則指向預設語言的檔案。&lt;/p&gt;
&lt;h2 id="hugo-langs-symlink"&gt;&lt;a href="https://github.com/YuShuanHsieh/hugo-langs-symlink"&gt;hugo langs symlink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;因此，side project &lt;a href="https://github.com/YuShuanHsieh/hugo-langs-symlink"&gt;github.com/YuShuanHsieh/hugo-langs-symlink&lt;/a&gt; 就是為了這個目的而誕生的，用我熟悉的 Go 語言來編寫，使用者可以透過參數來決定要建立 &lt;code&gt;symbolic link&lt;/code&gt; 的語言和檔案對象。Project 簡單地提供 &lt;code&gt;create&lt;/code&gt; 和 &lt;code&gt;remove&lt;/code&gt; 兩個 sub command ，這樣用戶就能直接在 local 端操作和刪除 &lt;code&gt;symbolic link&lt;/code&gt;，避免產生過多的 &lt;code&gt;symbolic link&lt;/code&gt; 而影響到 git commit。&lt;/p&gt;</description></item><item><title>Discourse Forums Deployment</title><link>https://yushuanhsieh.github.io/posts/2020-04-22-discourse-deployment/</link><pubDate>Wed, 22 Apr 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-04-22-discourse-deployment/</guid><description>&lt;p&gt;這兩天在試著部署 Discourse －目前主流的 forum open porject。雖然它有 cloud 版本可以用，不過因為基於一些因素，我們打算先自行部署，給團隊成員實際試用測試過後，再來看是否要使用官方提供的 Cloud 付費版本。而在部署的過程中發現蠻多問題的，所以也一併記錄下來，給想要自行部署的人參考。&lt;/p&gt;
&lt;h2 id="discourse-container"&gt;Discourse Container&lt;/h2&gt;
&lt;p&gt;首先在 Discourse container 部份，我們選擇由 bitnami 所維護的 &lt;a href="https://hub.docker.com/r/bitnami/discourse/"&gt;bitnami/discourse&lt;/a&gt; 版本，原因是它提供相對完整的 configuration 和流程，事後證明這個選擇也是對的，因為我有嘗試使用 Discourse 所提供的 container 來部署，結果根本是場災難，畢竟官方所提供的 container 本來就不適合用在自行部署，除了流程複雜之外，size 也大許多 (2.5GB)。&lt;/p&gt;
&lt;h3 id="version"&gt;Version&lt;/h3&gt;
&lt;p&gt;Discourse 版本部分，目前 (2020/04) 官方是 &lt;code&gt;2.5.0 beta&lt;/code&gt;，而 bitnami/discourse 則是 &lt;code&gt;2.4.1&lt;/code&gt; 也就是官方所提供的最新穩定版本，因此不會有太大的版本落差。&lt;/p&gt;</description></item><item><title>Trace transfer.sh open project</title><link>https://yushuanhsieh.github.io/posts/2020-04-15-transfer-sh-refactor/</link><pubDate>Wed, 15 Apr 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-04-15-transfer-sh-refactor/</guid><description>&lt;p&gt;因為工作需求，需要一個透過 cli 就可以 upload 和 download 的工具，剛好 open project &lt;code&gt;transfer.sh&lt;/code&gt; 有提供類似的功能，不過我們有額外的需求，包含每個 request 都要能 fiter IP 和執行 HTTP Basic Auth 驗證，因此就有這個機會來分析一下 &lt;code&gt;transfer.sh&lt;/code&gt; source code 並且後續可以針對我們需求來修改！&lt;/p&gt;
&lt;h2 id="source-code-分析"&gt;Source code 分析&lt;/h2&gt;
&lt;h3 id="http-router"&gt;HTTP Router&lt;/h3&gt;
&lt;p&gt;首先來看 &lt;code&gt;transfer.sh&lt;/code&gt; 的 source code，這個 project 其實程式碼蠻少的，所以大概花個幾個小時就可以大致了解運作方式。&lt;code&gt;transfer.sh&lt;/code&gt; 是一個簡單的 Web server，其 path router 是使用 &lt;code&gt;gorilla/mux&lt;/code&gt;，雖然 &lt;code&gt;gorilla/mux&lt;/code&gt; 的 path search 是 slice 設計， route 效率不比 radix tree router 效能好，不過因為這個 Web server 的 path 也不多，所以就還可以接受。&lt;/p&gt;</description></item><item><title>Multilingual Mode in Hugo</title><link>https://yushuanhsieh.github.io/posts/2020-04-07-hugo-merge/</link><pubDate>Tue, 07 Apr 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-04-07-hugo-merge/</guid><description>&lt;p&gt;紀錄用 Hugo site generator 建立多語言網站時所遇到的問題，與過程中相關的學習內容，包含 Hugo render 過程、source code trace 等。&lt;/p&gt;
&lt;h2 id="預備知識"&gt;預備知識&lt;/h2&gt;
&lt;h3 id="the-flow-of-hugo-render"&gt;The flow of Hugo Render&lt;/h3&gt;
&lt;p&gt;Hugo 是一個 Site Generator，那他是怎麼產出這些 static html 的呢？首先程式會先遍歷在 &lt;code&gt;content&lt;/code&gt; folder 底下所有的 folder 和 file，並且組成一個 &lt;code&gt;contentTree&lt;/code&gt; (題外話， contentTree 是採用 radix 資料結構)。然後再把這些 content node 根據 node type (e.g. type 可能是 sections or taxonomies) 去對應到 &lt;code&gt;layout&lt;/code&gt; folder 內的 template，接著 render 出最後的 html 頁面。(也可參閱 &lt;a href="https://github.com/gohugoio/hugo/blob/master/hugolib/site.go#L78"&gt;hugolib/site.go&lt;/a&gt; 由 Hugo 開發者所寫的簡易流程)&lt;/p&gt;</description></item><item><title>Go HTTP Routers - Chi/Echo/Gin/gorilla mux 實作細節與比較</title><link>https://yushuanhsieh.github.io/posts/2020-01-21-golang-router/</link><pubDate>Tue, 21 Jan 2020 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2020-01-21-golang-router/</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;之前做 API server，制定 route path 時有遇到一些問題，於是就順手看了幾個 HTTP router / web framework 的 router 部分實作方式，並且記錄下來，提供給大家做個參考。&lt;/p&gt;
&lt;h2 id="問題"&gt;問題&lt;/h2&gt;
&lt;p&gt;需要加入&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/stations/instances&lt;/li&gt;
&lt;li&gt;/stations/{id}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這兩個 path 對應到不同的 handlers。&lt;/p&gt;
&lt;h2 id="chi"&gt;Chi&lt;/h2&gt;
&lt;p&gt;package &lt;code&gt;github.com/go-chi/chi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;知名 HTTP router library &lt;code&gt;chi&lt;/code&gt;，其輕量、快速、handler 使用原生 &lt;code&gt;net/http&lt;/code&gt; struct，都是不錯的優勢。和多數主流的 HTTP router 相似，chi 的 router 是採用 &lt;a href="https://en.wikipedia.org/wiki/Radix_tree"&gt;radix tree&lt;/a&gt; 結構，比較特別的是 chi 將 node type 分成四種：&lt;/p&gt;</description></item><item><title>Start HTTP/2 running over cleartext TCP</title><link>https://yushuanhsieh.github.io/posts/2019-08-27-http2-h2c/</link><pubDate>Tue, 27 Aug 2019 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2019-08-27-http2-h2c/</guid><description>&lt;p&gt;![flow]({{ site.url }}/assets/images/h2c-flow.png)&lt;/p&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;主流使用 HTTP/2 時都是基於 TLS protocol，不過在 HTTP/2 RFC7540 規範中， HTTP/2 其實也可以直接基於 cleartext TCP 來溝通。這次主要介紹 based on cleartext TCP 的 HTTP/2 server 與 client 實作，後續會再加入 HTTP/2 結合 TLS protocol 的相關內容。&lt;/p&gt;
&lt;h2 id="http2-version-identification"&gt;HTTP/2 Version Identification&lt;/h2&gt;
&lt;p&gt;在 &lt;a href="https://httpwg.org/specs/rfc7540.html#versioning"&gt;RFC7540 3.1&lt;/a&gt; 中有明確定義出 HTTP/2 on TLS protocol or cleartext TCP 的識別號，這個識別主要用於 client 端詢問 server 對於 HTTP/2 的 protocol 支援，以及切換到 HTTP/2 的過程。&lt;/p&gt;</description></item><item><title>Go - Archive files with archive/tar lib</title><link>https://yushuanhsieh.github.io/posts/2018-09-09-go-tar-file/</link><pubDate>Sun, 09 Sep 2018 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2018-09-09-go-tar-file/</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;由於專案要提供 API 來讓使用者 export 匯出檔案， 因此需要將所需檔案集結成一個 archive file。這個流程是透過 Go 的標準 lib &lt;code&gt;archive/tar&lt;/code&gt; 來處理，以下文章將簡單介紹流程和實作方式，並於最後附上完整程式碼。&lt;/p&gt;
&lt;h2 id="tar"&gt;Tar&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; 在UNIX/Linux系統中是最常見的打包工具，透過 &lt;code&gt;tar&lt;/code&gt; 的協助，我們可以把數個檔案打包成一個 &lt;code&gt;&amp;lt;file name&amp;gt;.tar&lt;/code&gt; 檔案，以利進行後續處理。&lt;/p&gt;
&lt;p&gt;![Go-Tar-1.png]({{ site.url }}/assets/images/Go-Tar-1.png)&lt;/p&gt;
&lt;h3 id="tar-file-format"&gt;tar file format&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;.tar&lt;/code&gt; 的檔案格式主要是由 &lt;code&gt;file object&lt;/code&gt; 和其對應的 &lt;code&gt;header&lt;/code&gt; 所組成。 &lt;code&gt;header&lt;/code&gt; 裡面包含了一個 file 的 metadata（例如檔案名稱，數據大小等），這樣系統就可以透過 header 去檢測檔案屬性和完整度。&lt;/p&gt;</description></item><item><title>Google Sign-in with OAuth 2.0</title><link>https://yushuanhsieh.github.io/posts/2018-08-25-go-google-oauth/</link><pubDate>Sat, 25 Aug 2018 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2018-08-25-go-google-oauth/</guid><description>&lt;h2 id="前言"&gt;前言：&lt;/h2&gt;
&lt;p&gt;由於目前專案是以 Embedded System 為主，比較少有機會接入第三方 api 的機會，所以這次 side project 就以 Google Sign-in for Web application with Go 的流程當作練習。由於網路上可以找到很多範例，所以在以下文章中會側重在原理 + 為什麼要這樣做，希望除了寫 code 之外，還能建立起基本概念。&lt;/p&gt;
&lt;h2 id="oauth-20"&gt;Oauth 2.0&lt;/h2&gt;
&lt;p&gt;要實作 Google Sign-in 流程之前，不免要來簡單提到 Oauth 2.0。 OAuth 是一個用於授權認證的標準協議(RFC 6749)，與一般網站常用到的個人帳號驗證機制不同的地方是，OAuth 強調&lt;strong&gt;第三方應用程式授權機制&lt;/strong&gt;，所以它的內容有明確定義出各角色定義，包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;resource owner&lt;/li&gt;
&lt;li&gt;resource server&lt;/li&gt;
&lt;li&gt;client&lt;/li&gt;
&lt;li&gt;authorization server&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以這次要實作的場景為例，使用者要透過 Google 帳號來登入我的網站，這裡 &lt;code&gt;resource owner&lt;/code&gt; 是指使用者，&lt;code&gt;client&lt;/code&gt; 是指我的網站，&lt;code&gt;resource server&lt;/code&gt; 和 &lt;code&gt;authorization server&lt;/code&gt; 則都是指 Google 所提供的服務。&lt;/p&gt;</description></item><item><title>Go Fundamental - Array</title><link>https://yushuanhsieh.github.io/posts/2018-08-11-go-fundamental-array/</link><pubDate>Sat, 11 Aug 2018 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2018-08-11-go-fundamental-array/</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在學 Go，而之前有一些 C 的基礎，因此在學到 Go 的 Array 時，發現它和 C 的 Array 差異性蠻大的，所以特別記錄下來。&lt;/p&gt;
&lt;h2 id="array"&gt;Array&lt;/h2&gt;
&lt;p&gt;Go&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;students&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0550ae"&gt;:=&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#1f2328"&gt;[&lt;/span&gt;&lt;span style="color:#0550ae"&gt;3&lt;/span&gt;&lt;span style="color:#1f2328"&gt;]&lt;/span&gt;&lt;span style="color:#cf222e"&gt;string&lt;/span&gt;&lt;span style="color:#1f2328"&gt;{&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;student1&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;student2&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt;&lt;span style="color:#fff"&gt; &lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;student3&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;&lt;span style="color:#fff"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;C&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;"&gt;&lt;tr&gt;&lt;td style="vertical-align:top;padding:0;margin:0;border:0;"&gt;
&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;&lt;code&gt;&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%"&gt;
&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;char&lt;/span&gt; &lt;span style="color:#0550ae"&gt;*&lt;/span&gt;students&lt;span style="color:#1f2328"&gt;[&lt;/span&gt;&lt;span style="color:#0550ae"&gt;3&lt;/span&gt;&lt;span style="color:#1f2328"&gt;]&lt;/span&gt; &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;student1&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;student2&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;student3&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="gos-arrays-are-values"&gt;Go&amp;rsquo;s arrays are values.&lt;/h3&gt;
&lt;p&gt;首先，最大的不同點是： Go 的 Array 是一個 Value，也就是 &lt;code&gt;students&lt;/code&gt; 這個 Variable 就代表整個 Array 。反之， C 在宣告 Array 後， &lt;code&gt;students&lt;/code&gt; 是代表指向 Array 第一個 element 的 pointer，而不是整個 Array。&lt;/p&gt;</description></item></channel></rss>