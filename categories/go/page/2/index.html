<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A technical blog about software engineering, system design, and modern development practices."><meta name=author content="Cherie Hsieh"><title>Go — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771496291"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Go</h1></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2020-06-24>Jun 24, 2020</time>
<span class=reading-time>5 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-06-24-strings-builder/>Escape analysis issues of strings builder</a></h2><p class=post-list-summary><p>在分享 <a href=https://yushuanhsieh.github.io/post/2020-06-01-string-to-slice/>Go string to slice 議題</a> 文章後，有朋友(感謝@陳孝思)在社團裡面分享另一個議題，關於在 strings package 的 builder 中有避免 escape analysis 的方式。基於這個分享，我就去查閱了相關 source code 和 issues ，並且整理成此文章。</p><h2 id=escape-analysis>Escape analysis</h2><p>escape analysis 是協助 Go compiler 判斷要將 variable 分配在 goroutine stack 還是 heap 的方式，而由於變數的分配位置會關係到 garbage collection 進而影響效能，因此 escape analysis 也是 Gopher 所在意的議題之一。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-06-01>Jun 1, 2020</time>
<span class=reading-time>4 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-06-01-string-to-slice/>Go string to slice 議題</a></h2><p class=post-list-summary><p>日前在看 Go runtime/string.go source code 的時候，意外看到一篇文章 <a href=https://www.cnblogs.com/mushroom/p/8998538.html>Go中string转[]byte的陷阱</a>，不過這篇文章的日期間隔已久，Go version 也從文章中的 1.10 改版到 1.14 了，所以想要更新一下這個議題現況。</p><p><img src=/posts/string-to-slice.png alt=hugo></p><h2 id=version>Version</h2><p>Go version: 1.14</p><h2 id=問題摘要>問題摘要</h2><h3 id=1-runtimestringtoslicebyte>1. runtime.stringtoslicebyte</h3><p>首先，文章中提到的例子：</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#cf222e>func</span><span style=color:#fff> </span><span style=color:#6639ba>main</span><span style=color:#1f2328>()</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>s</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#1f2328>[]</span><span style=color:#6639ba>byte</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;&#34;</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>s1</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#6639ba>append</span><span style=color:#1f2328>(</span><span style=color:#1f2328>s</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0a3069>&#39;a&#39;</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>s2</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#6639ba>append</span><span style=color:#1f2328>(</span><span style=color:#1f2328>s</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0a3069>&#39;b&#39;</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#57606a>//fmt.Println(s1, &#34;==========&#34;, s2)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>    </span><span style=color:#1f2328>fmt</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Println</span><span style=color:#1f2328>(</span><span style=color:#6639ba>string</span><span style=color:#1f2328>(</span><span style=color:#1f2328>s1</span><span style=color:#1f2328>),</span><span style=color:#fff> </span><span style=color:#0a3069>&#34;==========&#34;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#6639ba>string</span><span style=color:#1f2328>(</span><span style=color:#1f2328>s2</span><span style=color:#1f2328>))</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span></code></pre></td></tr></table></div></div><p>在沒有 <code>fmt.Println(s1, "==========", s2)</code> 這一行的情況下，output 會產生：</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-05-19>May 19, 2020</time>
<span class=reading-time>4 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-05-19-transfer.sh/>Side Project - Transfer.sh</a></h2><p class=post-list-summary><p>在 <a href=https://yushuanhsieh.github.io/post/2020-04-15-transfer-sh-refactor/>Trace transfer.sh open project</a> 有提到我目前正在調整 <a href=https://github.com/dutchcoders/transfer.sh>transfer.sh</a> 這個 open source project，把它修改成內部所需要的一個 service，而之前已經改得差不多了，所以簡單地來介紹一下修改了哪些內容：</p><h2 id=需求>需求</h2><ol><li>每個 download request 能依需求驗證 IP address 和 user account / password</li><li>能使用外部 service 來驗證 user account</li><li>需能支援 curl cmd tool</li><li>k8s deployment</li></ol><h2 id=修改項目>修改項目</h2><h3 id=1-middleware-chain>1. Middleware Chain</h3><p>根據需求 1，在 <code>getHandler</code> 前加入 middleware chain，其中包含：</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-29>Apr 29, 2020</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-29-hugo-symlinks/>Side Project - Symlink Generator for Multi-lang Hugo Site</a></h2><p class=post-list-summary><p>在 <a href=https://yushuanhsieh.github.io/post/2020-04-07-hugo-merge/>Multilingual Mode in Hugo</a> 這篇文章中有提到目前使用 Hugo site generator 產生 multi-lang site 的問題，使用者必須要為每個語言都建立一個檔案，才不會造成最後在產生網站後，發生某一個語言的頁面遺失問題。（例如，使用者一定要建立 <code>about.md</code>, <code>about.tw.md</code>，這樣當瀏覽者在選擇中文語言的網站時，才會顯示出 about 頁面）。這樣其實會造成不少困擾，因為不是每個語言都可以這麼即時的被翻譯完成，但我們又不希望有頁面遺失，因此需要透過一些方式來解決這個問題。</p><p>而其中一個方法就是建立一個 <code>symbolic link</code>，當某個語言還沒被翻譯時，就建立一個 symbolic link 來代表這個檔案，然後實際檔案則指向預設語言的檔案。</p><h2 id=hugo-langs-symlink><a href=https://github.com/YuShuanHsieh/hugo-langs-symlink>hugo langs symlink</a></h2><p>因此，side project <a href=https://github.com/YuShuanHsieh/hugo-langs-symlink>github.com/YuShuanHsieh/hugo-langs-symlink</a> 就是為了這個目的而誕生的，用我熟悉的 Go 語言來編寫，使用者可以透過參數來決定要建立 <code>symbolic link</code> 的語言和檔案對象。Project 簡單地提供 <code>create</code> 和 <code>remove</code> 兩個 sub command ，這樣用戶就能直接在 local 端操作和刪除 <code>symbolic link</code>，避免產生過多的 <code>symbolic link</code> 而影響到 git commit。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-22>Apr 22, 2020</time>
<span class=reading-time>11 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-22-discourse-deployment/>Discourse Forums Deployment</a></h2><p class=post-list-summary><p>這兩天在試著部署 Discourse －目前主流的 forum open porject。雖然它有 cloud 版本可以用，不過因為基於一些因素，我們打算先自行部署，給團隊成員實際試用測試過後，再來看是否要使用官方提供的 Cloud 付費版本。而在部署的過程中發現蠻多問題的，所以也一併記錄下來，給想要自行部署的人參考。</p><h2 id=discourse-container>Discourse Container</h2><p>首先在 Discourse container 部份，我們選擇由 bitnami 所維護的 <a href=https://hub.docker.com/r/bitnami/discourse/>bitnami/discourse</a> 版本，原因是它提供相對完整的 configuration 和流程，事後證明這個選擇也是對的，因為我有嘗試使用 Discourse 所提供的 container 來部署，結果根本是場災難，畢竟官方所提供的 container 本來就不適合用在自行部署，除了流程複雜之外，size 也大許多 (2.5GB)。</p><h3 id=version>Version</h3><p>Discourse 版本部分，目前 (2020/04) 官方是 <code>2.5.0 beta</code>，而 bitnami/discourse 則是 <code>2.4.1</code> 也就是官方所提供的最新穩定版本，因此不會有太大的版本落差。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-15>Apr 15, 2020</time>
<span class=reading-time>8 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-15-transfer-sh-refactor/>Trace transfer.sh open project</a></h2><p class=post-list-summary><p>因為工作需求，需要一個透過 cli 就可以 upload 和 download 的工具，剛好 open project <code>transfer.sh</code> 有提供類似的功能，不過我們有額外的需求，包含每個 request 都要能 fiter IP 和執行 HTTP Basic Auth 驗證，因此就有這個機會來分析一下 <code>transfer.sh</code> source code 並且後續可以針對我們需求來修改！</p><h2 id=source-code-分析>Source code 分析</h2><h3 id=http-router>HTTP Router</h3><p>首先來看 <code>transfer.sh</code> 的 source code，這個 project 其實程式碼蠻少的，所以大概花個幾個小時就可以大致了解運作方式。<code>transfer.sh</code> 是一個簡單的 Web server，其 path router 是使用 <code>gorilla/mux</code>，雖然 <code>gorilla/mux</code> 的 path search 是 slice 設計， route 效率不比 radix tree router 效能好，不過因為這個 Web server 的 path 也不多，所以就還可以接受。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-07>Apr 7, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-07-hugo-merge/>Multilingual Mode in Hugo</a></h2><p class=post-list-summary><p>紀錄用 Hugo site generator 建立多語言網站時所遇到的問題，與過程中相關的學習內容，包含 Hugo render 過程、source code trace 等。</p><h2 id=預備知識>預備知識</h2><h3 id=the-flow-of-hugo-render>The flow of Hugo Render</h3><p>Hugo 是一個 Site Generator，那他是怎麼產出這些 static html 的呢？首先程式會先遍歷在 <code>content</code> folder 底下所有的 folder 和 file，並且組成一個 <code>contentTree</code> (題外話， contentTree 是採用 radix 資料結構)。然後再把這些 content node 根據 node type (e.g. type 可能是 sections or taxonomies) 去對應到 <code>layout</code> folder 內的 template，接著 render 出最後的 html 頁面。(也可參閱 <a href=https://github.com/gohugoio/hugo/blob/master/hugolib/site.go#L78>hugolib/site.go</a> 由 Hugo 開發者所寫的簡易流程)</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-01-21>Jan 21, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-01-21-golang-router/>Go HTTP Routers - Chi/Echo/Gin/gorilla mux 實作細節與比較</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>之前做 API server，制定 route path 時有遇到一些問題，於是就順手看了幾個 HTTP router / web framework 的 router 部分實作方式，並且記錄下來，提供給大家做個參考。</p><h2 id=問題>問題</h2><p>需要加入</p><ol><li>/stations/instances</li><li>/stations/{id}</li></ol><p>這兩個 path 對應到不同的 handlers。</p><h2 id=chi>Chi</h2><p>package <code>github.com/go-chi/chi</code></p><p>知名 HTTP router library <code>chi</code>，其輕量、快速、handler 使用原生 <code>net/http</code> struct，都是不錯的優勢。和多數主流的 HTTP router 相似，chi 的 router 是採用 <a href=https://en.wikipedia.org/wiki/Radix_tree>radix tree</a> 結構，比較特別的是 chi 將 node type 分成四種：</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-08-27>Aug 27, 2019</time>
<span class=reading-time>14 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-08-27-http2-h2c/>Start HTTP/2 running over cleartext TCP</a></h2><p class=post-list-summary><p>![flow]({{ site.url }}/assets/images/h2c-flow.png)</p><h2 id=前言>前言</h2><p>主流使用 HTTP/2 時都是基於 TLS protocol，不過在 HTTP/2 RFC7540 規範中， HTTP/2 其實也可以直接基於 cleartext TCP 來溝通。這次主要介紹 based on cleartext TCP 的 HTTP/2 server 與 client 實作，後續會再加入 HTTP/2 結合 TLS protocol 的相關內容。</p><h2 id=http2-version-identification>HTTP/2 Version Identification</h2><p>在 <a href=https://httpwg.org/specs/rfc7540.html#versioning>RFC7540 3.1</a> 中有明確定義出 HTTP/2 on TLS protocol or cleartext TCP 的識別號，這個識別主要用於 client 端詢問 server 對於 HTTP/2 的 protocol 支援，以及切換到 HTTP/2 的過程。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2018-09-09>Sep 9, 2018</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-09-09-go-tar-file/>Go - Archive files with archive/tar lib</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>由於專案要提供 API 來讓使用者 export 匯出檔案， 因此需要將所需檔案集結成一個 archive file。這個流程是透過 Go 的標準 lib <code>archive/tar</code> 來處理，以下文章將簡單介紹流程和實作方式，並於最後附上完整程式碼。</p><h2 id=tar>Tar</h2><p><code>tar</code> 在UNIX/Linux系統中是最常見的打包工具，透過 <code>tar</code> 的協助，我們可以把數個檔案打包成一個 <code>&lt;file name>.tar</code> 檔案，以利進行後續處理。</p><p>![Go-Tar-1.png]({{ site.url }}/assets/images/Go-Tar-1.png)</p><h3 id=tar-file-format>tar file format</h3><p><code>.tar</code> 的檔案格式主要是由 <code>file object</code> 和其對應的 <code>header</code> 所組成。 <code>header</code> 裡面包含了一個 file 的 metadata（例如檔案名稱，數據大小等），這樣系統就可以透過 header 去檢測檔案屬性和完整度。</p></p></article></div><ul class="pagination pagination-default"><li class=page-item><a href=/categories/go/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/categories/go/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/categories/go/ aria-label="Page 1" class=page-link role=button>1</a></li><li class="page-item active"><a aria-current=page aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/categories/go/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/categories/go/page/3/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/categories/go/page/3/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>