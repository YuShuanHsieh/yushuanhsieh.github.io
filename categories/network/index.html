<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A technical blog about software engineering, system design, and modern development practices."><meta name=author content="Cherie Hsieh"><title>Network — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771486583"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Network</h1></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2020-07-05>Jul 5, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-07-05-docker-network/>Cross-Network Container Communication</a></h2><p class=post-list-summary><p>在 Docker 的網路規則中，由於 <code>DOCKER-ISOLATION-STAGE-1</code>、<code>DOCKER-ISOLATION-STAGE-2</code> 兩個 iptables chain 的關係，因此不同 Docker network 連結的 container 是無法互相溝通的。不過，我們可以透過建立 router 的手段來規避掉 chain 的限制，讓 container 收到其他 container 來的packages。此方式涉及到 <code>Linux Bridge</code> 處理封包的方式和基本網路知識，希望透過此介紹，來更了解 network stack 與 packages 處理流程。</p><h2 id=docker-container-network>Docker Container Network</h2><p>我們知道，Docker 的網路實現是基於 Linux network namespace，Linux network bridge，與 virtual ethernet device 所架構而成的(可參閱 <a href=https://success.docker.com/article/networking#linuxnetworkfundamentals>Linux Network Fundamentals</a>)。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-08-27>Aug 27, 2019</time>
<span class=reading-time>14 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-08-27-http2-h2c/>Start HTTP/2 running over cleartext TCP</a></h2><p class=post-list-summary><p>![flow]({{ site.url }}/assets/images/h2c-flow.png)</p><h2 id=前言>前言</h2><p>主流使用 HTTP/2 時都是基於 TLS protocol，不過在 HTTP/2 RFC7540 規範中， HTTP/2 其實也可以直接基於 cleartext TCP 來溝通。這次主要介紹 based on cleartext TCP 的 HTTP/2 server 與 client 實作，後續會再加入 HTTP/2 結合 TLS protocol 的相關內容。</p><h2 id=http2-version-identification>HTTP/2 Version Identification</h2><p>在 <a href=https://httpwg.org/specs/rfc7540.html#versioning>RFC7540 3.1</a> 中有明確定義出 HTTP/2 on TLS protocol or cleartext TCP 的識別號，這個識別主要用於 client 端詢問 server 對於 HTTP/2 的 protocol 支援，以及切換到 HTTP/2 的過程。</p></p></article></div></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>