<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A technical blog about software engineering, system design, and modern development practices."><meta name=author content="Cherie Hsieh"><title>Operating System — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771486583"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Operating System</h1></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2021-05-23>May 23, 2021</time>
<span class=reading-time>12 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-05-23-lab4-multiprocessor/>CSE 506 Lab 4 - Multiprocessor Support and Cooperative Multitasking</a></h2><p class=post-list-summary><p>Lab 4 包含三個部分，其中 A 部分介紹 x86 架構的 multiprocessor 啟動與初始化流程，並且實作簡易的 round-robin process scheduling。而我認為從 bootstrap processor 啟動並初始化，到透過 bootstrap processor 把其他的 processor 啟動的整個過程相當重要，可以讓新手更具體地知道 multiprocessor 的運作方式。</p><p>JOS 實作 intel <a href=https://en.wikipedia.org/wiki/MultiProcessor_Specification>MultiProcessor Specification(MPS)</a> 標準，在看 source code 的時候，搭配這個文件來看會更加理解每項步驟的用意。</p><p><strong>Note:</strong>
Multiprocessor 架構會依據設計而有所不同，以下所提到的內容皆以 x86 MPS 制定的規格為主。</p><h2 id=multiprocessor>Multiprocessor</h2><h3 id=architecture>Architecture</h3><p>Multiprocessor 架構下，每個 processor 有各自的 L1 cache 和 APIC，並且透過 ICC (interrupt controller communications) bus 進行溝通。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2021-01-26>Jan 26, 2021</time>
<span class=reading-time>12 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-01-26-lab3_2/>CSE 506 Lab 3 - Interrupts</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>2020 年過去了，因為年底各種考試和工作， Lab3 下半部份延遲到現在才完成。雖然拖蠻久的，但是往好的方向看就是有在持續進行下去，沒有放棄就是好結局！最近心境上有蠻多變化的，其中本來對於目前工作內容很疑惑，覺得跟純軟生活落差太大，但是在工作中慢慢地發現自己對於 security 領域的認知嚴重不足，如果能好好學習 security 相關知識，對於自己和未來發展還是挺有幫助的，結合 security 與 embedded or cloud 去發展，是一個有趣又有挑戰性的目標，因此目前就朝著這方向努力，希望今年可以在 COSCUP 分享 security 相關議題。</p><h2 id=lab-3-interrupts>Lab 3 Interrupts</h2><p>在開始實作 interrupt 之前，先結合上一篇 <a href=https://yushuanhsieh.github.io/post/2020-11-25-lab3_1/>CSE 506 Lab 3 - User Environments(Processes)</a> environment(process) 的觀念，綜觀一下 interrupt 結合 environment context switch 的 interrupt handle 過程。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-11-25>Nov 25, 2020</time>
<span class=reading-time>14 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-11-25-lab3_1/>CSE 506 Lab 3 - User Environments(Processes)</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>之前在辦活動的時候，得知有朋友在 follow 我的 Blog ，真是讓我非常訝異，因為我一直是默默撰寫文章，而且雖然我有參與 Golang 和 GDG 社群，但是我寫的內容很常都跟 Golang 和 Google 技術沒什麼太大關係 XD 非常感謝各位的觀看，之前有近兩個月都沒更新，感覺有點罪惡，以後會盡量定期更新的。</p><p>目前除了自修 CSE 506 課程之外，還有學習 RISC-V instruction 以及 pipeline，因為過往經驗都是看 x86_64 instruction 居多，現在改看 RISC-V 還蠻不習慣的。另外就是還想學用 Rust 寫 kernel module，目前趨勢是有些 Kernel developers 嘗試將 Rust code 結合進 Linux kernel 中，再加上 Rust 的發展也蠻成熟，是時候抽空來學習一下。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-11-15>Nov 15, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-11-15-lab2_2/>CSE 506 Lab2 - Memory Management and Virtual Memory Mapping</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>上次寫完 Lab 2 source code study 之後，一晃眼就過了近兩個月。中間被各種事物攔截，加上剛好有些機遇和機會，因此挪了一些時間去準備，等事情有比較明朗後再跟大家分享。此外，學校也開學了，這學期修了偏硬體架構的課程，包含 RISC-V 和架構效能分析等，單智君教授的教學內容很好，聲音也很溫柔，非常喜歡這位教授的課程。</p><p>這時間還遇上 Macbook 螢幕完全無法顯示的意外，經由朋友提醒，2016 年產的 13 吋 Macbook Pro 有螢幕背光災情，Apple 有提供免費召回維修的服務，因此花了一些時間送修。而 Apple 的服務也還不錯，整個螢幕換新，看來又可以撐好一陣子了 &lt;3</p><h2 id=lab-2>Lab 2</h2><p><a href=https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/lab2.html>實驗說明文件</a></p><h2 id=part-1-physical-page-management>Part 1: Physical Page Management</h2><p>Part 1 是實作 physical memory allocator。在 <a href=https://yushuanhsieh.github.io/post/2020-09-12-lab2-1/>CSE 506 Lab2 - E820 Memory Map & Page Translation (1)</a> 可以看到系統在執行 kernel code 前，有先在 bootstrap 階段建立 page translation 所需的 pml4 table，以確保 kernel code 可以正確地被執行，不過在 kernel code 運行階段，我們需要建立新的 pml4 table ，來讓我們可以有更多控制權。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-09-12>Sep 12, 2020</time>
<span class=reading-time>16 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-09-12-lab2-1/>CSE 506 Lab2 - E820 Memory Map & Page Translation (1)</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>之前是看 <a href=https://www.cs.unc.edu/~porter/courses/comp790/s20/index.html>COMP790</a> 的課程，但是實作起來發現有點問題，而且題目跟實際 source code 說明不太一樣。在花了很多時間釐清之後，發現原課程內容可能來自於 <a href=https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/schedule.html>CSE 506: Lecture from Stony Brook University</a>，仔細看了一下 CSE 506 的 Lab 課程，發現題目與 source code 相符程度較高，因此後續會改看 CSE 506 這系列課程。</p><p>這次 Lab 花了大概 20 小時來實作，主要原因是有些 source code 的註解是錯誤的，所以單看註解會產生很多疑問，必須實作和觀察才能釐清。這次實驗也讓我體會到，如果覺得哪邊有不太理解的地方，就直接做實驗來驗證，而不要單看註解來去試圖理解它上面的意思，因為如果註解不是正確的，那這些時間也就浪費了。</p><p>因為這次實驗要整理的內容蠻多的，擔心文章太長，所以會分成數篇來貼！</p><h2 id=lab-實驗介紹>Lab 實驗介紹</h2><p>Lab 2 是實作 physical memory allocator 和 virtual memory allocator，其中最重要的是清楚 physical memory 與 virtual memory 之間的轉換，以及如何運用 Lab 2 的 <code>PageInfo</code> c structure 把兩者 mapping 起來。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-08-25>Aug 25, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-08-25-comp790-lab1/>CSE 506 Lab1 - The Stack</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>課程 <a href=https://www.cs.unc.edu/~porter/courses/comp790/s20/index.html>Operating System Implementation</a>，Lab1 <a href=https://www.cs.unc.edu/~porter/courses/comp790/s20/lab1.html>x86 Assembly and Bootloader</a> 是個簡單的實作開場(Lab 源自於 MIT 課程)，不過其中卻有蠻多學習的地方。這次來記錄一下 Lab 1 中的 <strong>The Stack</strong> 實作部分，實作過程中除了需要用 gdb 之外，也需要搭配 asm code。</p><h2 id=實作內容>實作內容</h2><p>在教學程式中，會呼叫 test_backtrace(5)，接著跑 recursion 直到碰到終止條件為止。</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#6639ba>i386_init</span><span style=color:#1f2328>(</span><span style=color:#cf222e>void</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6639ba>test_backtrace</span><span style=color:#1f2328>(</span><span style=color:#0550ae>5</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>void</span> <span style=color:#6639ba>test_backtrace</span><span style=color:#1f2328>(</span><span style=color:#cf222e>int</span> x<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6639ba>cprintf</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;entering test_backtrace %d</span><span style=color:#0a3069>\n</span><span style=color:#0a3069>&#34;</span><span style=color:#1f2328>,</span> x<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>if</span> <span style=color:#1f2328>(</span>x <span style=color:#0550ae>&gt;</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>        <span style=color:#6639ba>test_backtrace</span><span style=color:#1f2328>(</span>x<span style=color:#0550ae>-</span><span style=color:#0550ae>1</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>else</span>
</span></span><span style=display:flex><span>        <span style=color:#6639ba>mon_backtrace</span><span style=color:#1f2328>(</span><span style=color:#0550ae>0</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>,</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span>    <span style=color:#6639ba>cprintf</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;leaving test_backtrace %d</span><span style=color:#0a3069>\n</span><span style=color:#0a3069>&#34;</span><span style=color:#1f2328>,</span> x<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我們的目標，就是實作 <code>mon_backtrace</code>，追蹤進入 test_backtrace function 以及 recursion 的過程。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-08-24>Aug 24, 2020</time>
<span class=reading-time>4 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-08-24-comp790-tool/>CSE 506 Lab 環境建置</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>由於下學期要上計算機結構的課程，所以趁著開課之前來複習一下 OS。這次看的課程是 UNC Operating System Implementation，基本上這課程也是引用 MIT 知名的 JOS 實作，再加上清楚明瞭的 Slides，光是一堂課就能有蠻多地收穫。</p><p>這次先來記錄一下實作 Lab1 所遇到的一些問題和環境建立過程。不得不說這課程的環境建置說明沒有很清楚，所以浪費了一些時間在配置正確環境和編譯器。</p><h2 id=環境建立>環境建立</h2><p>Host: MacPro macOS 10.15.6</p><h3 id=tools>Tools</h3><ul><li>VSCode</li><li>Vagrant</li><li>VirtualBox</li><li>Ubuntu 16.04 64 bit</li><li>GNU binutils:2.19</li><li>GNU gcc:4.1.2</li><li>GNU GDB 7.7.1 (要下載 source code 並且修改檔案)</li><li>MIT版 Qemu <code>https://github.com/geofft/qemu.git -b 6.828-1.7.0</code></li></ul><h4 id=vagrant-configuration>Vagrant Configuration</h4><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-shell data-lang=shell><span style=display:flex><span>config.vm.box <span style=color:#0550ae>=</span> <span style=color:#0a3069>&#34;ubuntu/xenial64&#34;</span>
</span></span><span style=display:flex><span>  config.vm.provider <span style=color:#0a3069>&#34;virtualbox&#34;</span> <span style=color:#cf222e>do</span> <span style=color:#1f2328>|</span>vb<span style=color:#1f2328>|</span>
</span></span><span style=display:flex><span>    vb.customize <span style=color:#0550ae>[</span><span style=color:#0a3069>&#34;modifyvm&#34;</span>, :id, <span style=color:#0a3069>&#34;--nested-hw-virt&#34;</span>, <span style=color:#0a3069>&#34;on&#34;</span><span style=color:#0550ae>]</span>
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span>end
</span></span></code></pre></td></tr></table></div></div><p>環境配置是在 VM 中跑 Qemu + KVM ，因此在設定 configuration 時，要將 VritualBox 的 <code>nested-hw-virt</code> 開啟。</p></p></article></div></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>