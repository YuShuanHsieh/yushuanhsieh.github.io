<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A technical blog about software engineering, system design, and modern development practices."><meta name=author content="Cherie Hsieh"><title>Other — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771486583"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Other</h1></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2024-01-20>Jan 20, 2024</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2024-01-21-status_update/>近況更新</a></h2><p class=post-list-summary><p>自從 2022 年換了新工作，花了蠻多心力在適應工作環境和內容，就先停止更新了 blog。而新工作除了技術之外，我認為自我成長最多的部分應該是跨部門合作溝通、專案時程安排，以及簡報和語言能力等軟實力。其實當時在換工作的時候，就有預期在新的工作崗位上能夠獲得什麼，我想身為資深工程師，技術的持續精進已經是要能自我安排的日常任務，新職位的技術學習已經不是首要考量，反之希望自己能更加強於與人溝通和表達能力這部分。此外，技術學習也從不斷的跟進新技術，轉由能夠判斷當前的情境和預算資源應該要使用怎樣的架構，如何能在滿足使用者需求和時程的安排下將功能完成，並且考慮到不同錯誤和意外處理的情況。</p><p>老實說，新工作帶來蠻大的工作壓力，可能也是自我期許比較高，因此這一年花費了非常多的時間在了解公司內部狀況，和如何能將自己的能力正確地發揮在工作崗位。最終在績效表現上， 2022 和 2023 年有蠻不錯的正向回饋，希望新的一年 2024 年也可以繼續朝目標邁進。</p><h2 id=2023-年回顧>2023 年回顧</h2><h3 id=語文能力>語文能力</h3><ol><li>講了一場全英文 tech sharing</li><li>2 小時的全英文面試主考官</li><li>每週持續唸英文和上英文課</li></ol><h3 id=技術精進>技術精進</h3><ol><li>Python 從 0 經驗到 master (?)</li><li>除了 performance，更加留意在意外處理和錯誤判斷</li><li>不再只是專注開發，而是會考慮到後續的維運流程和 monitoring</li></ol><h3 id=其他>其他</h3><ol><li>矯正牙齒</li><li>拿到汽車駕照</li><li>學習投資和買房</li></ol><h2 id=2024-年展望>2024 年展望</h2><ol><li>希望能把握更多全英文的面談機會和場合</li><li>更多架構設計和 operation 的實務經驗</li><li>深入研究 K8s 底層原理和開發 k8s-native 的 application</li><li>買特斯拉 🚗</li></ol></p></article><article class=post-list-item><div class=post-meta><time datetime=2022-01-01>Jan 1, 2022</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2022-01-01-review-2021/>2021 年度回顧</a></h2><p class=post-list-summary><p>2022 新的一年到來，就來回顧一下去年所經歷的重要事情，並且規劃 2022 年的大方向。</p><h2 id=工作>工作</h2><h3 id=回顧>回顧</h3><p>2021 年工作最大的轉變就是從內部 IT 部門轉換到產品向 firmware 部門。在 2020 年時我有約略提到自己在 IT 部門面臨到不適應問題，當時是覺得要把重心放在研究跟公司產品相關 security 專業知識，也確實在轉換心境後有了不少收穫。不過在年中時很榮幸地從 IT 部門正式轉調到 firmware 部門，參與了幾個客戶專案，也主動進行產品 firmware 架構重構發想和討論，更具體的對公司產品做出貢獻，整體來說很有成就感。</p><p>在工作中學習確實比自己進修還要有幫助，不過之前進修中所累積的知識也讓我能在工作迅速上手，並且更快速地找到該改善的方向和問題點。當然 IP 廠 firmware 相關的工作，除了提供公版 library 之外，另一個很重要的項目就是 IP 驗證，這個項目相較於開發工作其實較為繁瑣，而且如果很單純的做驗證，會覺得這個任務十分打雜，就是協助硬體測試而已。因此我在做驗證的時候，會從市場角度去思考客戶需要這功能的目的性，以及如何改善 firmware 架構來讓驗證流程自動化。假如這些功能真的只能手動，那就思考該怎樣減少手動的步驟，盡可能利用軟體工程來協助加快驗證的速度。我覺得工作中難免會遇到大家都不想做的打雜工作，但是這些打雜工作卻又是整個專案中不可或缺的一環，代表還是有其重要性，因此盡量從中找到可以學習的地方，能夠提高工作時的成就感。</p><h3 id=展望>展望</h3><p>2022 年工作中的展望，就是將目前 firmware 架構調整成更成熟且具彈性的架構，並且完善驗證自動化流程。在 2021 年的專案中了解到組織和客戶的需求，並且也知道目前的 firmware 具體的改善方向。所以 2022 年的目標就是可以解決這些痛點，使得整個 firmware 開發與 IP 驗證流程更佳順暢，讓自己有更多時間可以著墨在產業相關的專業知識學習和系統層面的架構思考。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2021-12-01>Dec 1, 2021</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-12-01-status-update/>12/1 生日快樂</a></h2><p class=post-list-summary><p>12/1 是我生日 :) 近期完成了一些事情，像是決定研究所論文題目、回歸 Golang meetup 進行分享、參與 2021 年度 DevFest 盛會，並做了人生中比較完整的一次健康檢查。</p><p>前幾年生日時，總是會立定幾項進修目標，一步一步督促自己完成，過程中也相當有成就感。不過今年在體驗健檢和周遭所發生的事物後，覺得進修固然重要，不過身體健康才是能持續進修的關鍵。所以今年生日的目標，就是專注在研究所課業和工作就好，在身心健康和行有餘力的情況下，再來考慮實作個人 side project 和修習其他專業知識。</p><h2 id=golang-meetup>Golang Meetup</h2><p>這次在年底有幸地參與了 11 月的 Golang Meetup。其實已經好一陣子都沒有寫 Go 了，都是以 C/C++ 為主，不過剛好有這機會玩起 TinyGo project，因此這次 Meetup 就針對 TinyGo compile 流程和 TinyGo 不同開發板的配置機制來介紹。其中這流程涉及到我們所謂的 porting 流程，所以也從中學習到不少。</p><p><img src=/posts/golang_2021.jpg alt></p><h2 id=devfest-2021>DevFest 2021</h2><p>Golang Meetup 結束後，緊接著就是 11/13 新竹和台中 GDG DevFest 聯合場。老實說這是我第一次參加 DevFest，所以看到專業的錄音器材很驚訝，覺得之前我的線上分享都不認真，因為如果收音品質不好的話，基本上參與的人也會覺得很吃力～告誡自己下次如果有想要繼續辦線上活動，一定要準備好基本的設備再去參加。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2021-05-07>May 7, 2021</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-04-23-life/>CSE 506 Lab 4 - Multiprocessor Support</a></h2><p class=post-list-summary><p>Lab 4 包含三個部分，其中 A 部分介紹 x86 架構的 multiprocessor 啟動與初始化流程，並且實作簡易的 round-robin process scheduling。而我認為從 bootstrap processor 啟動並初始化，到透過 bootstrap processor 把其他的 processor 啟動的整個過程相當重要，可以讓新手更具體地知道 multiprocessor 的運作方式。</p><p>JOS 實作 intel <a href=https://en.wikipedia.org/wiki/MultiProcessor_Specification>MultiProcessor Specification(MPS)</a> 標準，在看 source code 的時候，搭配這個文件來看會更加理解每項步驟的用意。</p><p><strong>Note:</strong>
Multiprocessor 架構會依據設計而有所不同，以下所提到的內容皆以 x86 MPS 制定的規格為主。</p><h2 id=multiprocessor-architecture>Multiprocessor Architecture</h2><p>Multiprocessor 架構下，每個 processor 有各自的 L1 cache 和 APIC，並且透過 ICC (interrupt controller communications) bus 進行溝通。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2021-04-22>Apr 22, 2021</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-04-22-life/>近況雜談</a></h2><p class=post-list-summary><p>一個月沒有更新 blog，因為遇上了一些事情要處理，再加上剛好正值工作轉換之際，以及面對研究所考試和 paper study，所以就停筆了，不過還是有在持續地進修，學習的包含 security 和 system design 部分，並且每天刷 leetcode 訓練邏輯能力防失智。</p><p>前陣子面試的時候，發現自己有很多不足之處，導致自己無法在面試時有比較好的表現，尤其對於一些久未使用的 protocol，關於它的特性和流程就不是這麼熟悉。檢討自己面試問題，主要是因為自己是佛系面試派，認為平常應該要持續地累積實力，因此不太會因為面試而刻意準備，就像是我去考研究所在職專班ㄧ樣，完全沒有看考古題就去考試了，如果沒有上就代表我實力還不夠。</p><p>但是這種想法用在面試上就蠻糟的，尤其現在面試的公司多是一線廠，光是競爭者的實力就很優異，再加上面試時可能會緊張，平常實力再打折，導致整體表現就是比其他 candidate 遜色。另外，現在面試蠻多會遇到 medium level 的演算法測驗，如果準備不夠的話，有時候會突然邏輯失常，無法發揮正常表現，這也是我應該要改進的地方。</p><p>總結來說，就是面試心態不夠慎重。1-3年內經驗的菜鳥工程師時期可能還可以靠平常實力去面試，不過當要去面試資深工程師時，就必須把過往專案接觸過的理論知識重新複習一遍，避免因為時間久遠而無法回答精確。</p><p>基於這些原因，最近也花時間整理專案上會用到的 protocol 與各種 service 運作原理，如果很不幸又需要面試，還可以拿出來快速複習一番 (但我現在不想再換工作 XD，覺得一些產業知識還是要累積起來才行)</p><p>閒聊完了，最近會開始整理文章並發文，同時還要準備 COSCUP 內容，希望能快點有靈感～</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2021-02-18>Feb 18, 2021</time>
<span class=reading-time>11 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-02-18-l1-cache-arm/>L1 Cache architecture in ARM</a></h2><p class=post-list-summary><h1 id=l1-cache-architecture>L1 Cache architecture</h1><p>之所以會看這個主題，是因為網路黑貓(Champ Yen)大大分享 ARM 從 virtual cache 轉到 physical cache 的利弊。雖然曾經從書上看過兩者差異性，不過沒搭配硬體架構，總覺得沒有好好了解。因此這篇整理了 ARM Programmer’s Guide 的內容，並透過實際例子來探討 VIVT (virtual indexed vritual tagged)、VIPT(virtual indexed physical tagged)、PIPT(physical indexed physical tagged) 的差異性。</p><h2 id=virtually-addressed-caches-vivt>Virtually Addressed Caches (VIVT)</h2><p>十多年前的 ARM Processor L1 cache 採用 VIVT cache 架構，在當時的 ARM architecture reference 5.5.1 節有提及主要的原因：</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2018-11-15>Nov 15, 2018</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-11-15-node-red/>Node-Red - Node 坑坑紀錄</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>最近工作接觸到 Node-RED，需要建立專屬的 Node，而在這過程中遇到蠻多坑的，所以特別紀錄一下。</p><h2 id=相關技術>相關技術</h2><ol><li><a href=https://nodejs.org/en/>Node.js</a> v10.11.0</li><li><a href=https://github.com/nodejs/node-gyp>node-gyp</a></li><li>docker</li><li>arm cross compile</li><li>Node-RED node development</li></ol><h2 id=坑坑相連>坑坑相連</h2><h3 id=1-node-red-docker-version--nodejs-version>1. Node-RED docker version & Node.js version</h3><h4 id=問題點>問題點</h4><p>沒有先確認官方 <a href=https://hub.docker.com/r/nodered/node-red-docker/>Node-RED docker</a> 所內含的 Node.js 版本，導致所建立的 node 無法在官方 Node-RED docker 中運行。</p><h4 id=說明>說明</h4><p>目前官方所提供的 Node-RED docker 中， 並沒有提供內建 Node.js 10.x 版本 (目前最高只提供到 Node.js 8.x)，而我的開發環境是使用 Node.js 10.11.0 版本，更不巧的是我又用到 Node.js 10.11.0 才有的 N-API functions，因此導致 node 在運行時直接出現 segmentation fault Error 訊息。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2018-11-04>Nov 4, 2018</time>
<span class=reading-time>5 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-11-04-mcu-cross-compiler/>Microprocessor System Lab. - Cross Compiler</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>其實整個課程已經看完了，只是因為寫 blog 需要準備很多資料，畢竟有些部分老師快速帶過，所以生產文章的速度遠不及看課程速度XD 這次要說的是 Cross Compiler，因為如果是安裝像是 <code>SW4STM32</code> IDE，它所有 cross compiler 設定都已經備妥妥了，使用者只要按一個蟲蟲鍵便能快速 Debugger，不過實際上它背後執行許多程序，只是因為都被自動配置好了，因此使用者不太需要去處理這些額外的環境設定。</p><h2 id=cross-compiler>Cross compiler</h2><p>當我們在開發 Embedded software 時，通常情況下，都是在自己所使用、性能比較好的 host PC 進行程式碼編寫和 compile，接著把 compile 過後的執行檔燒在開發板上（畢竟開發板的執行效率不如自己手上的電腦好，如果直接使用開發板來 compile，會 compile 到天荒地老吧）。</p><p>不過，大部分人使用的電腦都是 x86 系列，如果直接在電腦上使用一般 compiler，就只會編出僅供 x86 辨識的執行檔，而想要 compile 出其他 CPU 可以辨識的執行檔，就必須透過 <strong>cross compiler</strong> 的協助才行。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2018-11-02>Nov 2, 2018</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-11-02-aug-study/>10月份自我學習日誌回顧</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>這次十月份的學習方向和預設有點不太一樣，主要是因為某天在因緣際會之下，接觸到交大開放式課程 <code>微處理機系統實驗 Microprocessor System Lab.</code>，覺得實在是太有趣了，所以就欲罷不能的聽下去，順便把一些相關教學材料也買齊，好好學一下 MCU 。可以預知，接下來會繼續上曹孝櫟老師的 <code>嵌入式系統設計概論與實作 Introduction to Embedded Systems Design and Implementation</code> ，剛好本身也是在 IOT 產業，每天都要接觸到 Embedded Systems，這老師說的很好，讓我學習到很多 :D</p><h2 id=預設目標>預設目標</h2><ol><li>Protocol proctise MQTT and modbus</li><li>Operating System Book</li><li>Implementation: C (c-example)</li></ol><h2 id=每日學習內容>每日學習內容</h2><ul><li>10/31: Review STM32 Timer Configuration - OSI -> PLL -> SYSCLK, AHB, APB</li><li>10/30: USART - 1</li><li>10/29: LCD lecture - 字形檔 / display mem addr / cg rom / cg ram</li><li>10/28: Implement 7 segment LED and Interrupt and Exception 2</li><li>10/27: Interrupt and Exception 1</li><li>10/26: How to use Advanced Timer and Counter</li><li>10/25: Basic Timer concept and how to calculate correct time period. The concept of general timer and advanced timer</li><li>10/24: Got a board and practice basic I/O output. and blog post.</li><li>10/23: The algorithm of page replacement. Memory - map file (such as 顯示卡)</li><li>10/22: Virtual Memory - Demand Page / GPIO Input setting and DIP Switch</li><li>10/21: STM32 General purpose I/O configuration, memory map</li><li>10/20: Qemu enviorment / ARM STM 32 base assembly language</li><li>10/19: Page Table - Outer table, Hashtable / Modbus slave daemon implement</li><li>10/18: Parse Modbus Slave Data</li><li>10/17: Page Table and Mapping. (Page, Offset, Page Size, Byte Address)</li><li>10/16: Swap (mid-term scheduler) / Memory allocation - page, frame | Modbus slave data format parse</li><li>10/15: Implement sjf scheduler</li><li>10/14 : Process Syncchoronization</li><li>10/13: Implement Hashmap with a effective way / C unit test using Check framework.</li><li>10/12: Process Syncchoronization 204 - 207</li><li>10/11: C Source code trace: How to use & and FNV hash fun. The effective way to create hashmap.</li><li>10/10: EDF scheduling, Share scheduling, Linux CFS scheduling.</li><li>10/9: Protocol packet format study</li><li>10/8: Real-time Process Schedulers / C - How to use define # and ##</li><li>10/7: thread_pool</li><li>10/6: C - pthread / sem_wait / pthread_cond_wait</li><li>10/5: 星期五，休息</li><li>10/4: CPU scheduler concept</li><li>10/3: something you should note about using threads. Signal / thread pools</li><li>10/2: multi thread - thread content, models, and Pthread.</li><li>10/1: <code>RPC</code> concept (book 154 -160) / Linux <code>Netcat</code> / <code>Stub</code> class</li></ul></p></article><article class=post-list-item><div class=post-meta><time datetime=2018-10-24>Oct 24, 2018</time>
<span class=reading-time>8 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-10-24-mcu-study-1/>Microprocessor System Lab. - Nucleo-64 development board</a></h2><p class=post-list-summary><h2 id=前言>前言：</h2><p>在英國的時候，學校大多專注在純軟開發課程上，例如敏捷開發(Agile Development), Web Development, database 等。其中有一堂課令我印象深刻，就是用 logic Unit, MUX 零件自組 16 Instruction Processor，然後自己手動按 Clock 去 fetch / execute instrction，透過這樣的學習，讓我更清楚整個電腦實際運作 Code 的流程。</p><p>自從經過這樣的學習後，對於 Processor 總是有種幻想，雖然回到台灣之後都是在做純軟工作，不過還是很希望可以接觸到更多相關知識（在台灣這些都是資工基本課程，可惜我大學是偏資管，並沒有機會能修到這些課）。幸好，在交大課程找到 <code>微處理機系統實驗</code> 和 <code>嵌入式系統設計概論與實作</code> 這兩堂課程，其中<strong>曹孝櫟教授</strong>教的非常詳細又很有重點，讓我瞬間變他的腦粉啊 &lt;3</p><p>由於學的很開心，也收穫很多，就來記錄一下學習過程。</p><h2 id=課程連結>課程連結</h2><ol><li><a href="http://ocw.nctu.edu.tw/course_detail-v.php?bgid=9&amp;gid=0&amp;nid=572&amp;v5=KmvfobI87bA">Lecture03 Overview of STM32 Board/Development Environment</a></li></ol><h2 id=nucleo-64-development-board>Nucleo-64 development board</h2><p>這堂課是使用 <code>Nucleo</code> 系列板子，Processor 是 <code>ARM Cortex-4M</code>，所以就也買了類似的開發板來玩玩。我是從 <a href=https://www.taiwaniot.com.tw/>物聯網科技</a> 這邊買的，寄件速度快，有可以超商取貨，材料種類又多，很推薦這個網站。</p></p></article></div><ul class="pagination pagination-default"><li class="page-item disabled"><a aria-disabled=true aria-label=First class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Previous class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a aria-current=page aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/categories/other/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/categories/other/page/2/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/categories/other/page/2/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>