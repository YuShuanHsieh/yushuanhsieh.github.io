<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Raspberry Pi on Cherie's Tech Blog</title><link>https://yushuanhsieh.github.io/categories/raspberry-pi/</link><description>Recent content in Raspberry Pi on Cherie's Tech Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 10 Dec 2021 08:00:00 +0800</lastBuildDate><atom:link href="https://yushuanhsieh.github.io/categories/raspberry-pi/index.xml" rel="self" type="application/rss+xml"/><item><title>LCD 2004 module with Rasp Pico</title><link>https://yushuanhsieh.github.io/posts/2021-12-10-lcd-2004/</link><pubDate>Fri, 10 Dec 2021 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2021-12-10-lcd-2004/</guid><description>&lt;p&gt;LCD 2004/1602 顯示模組應該是玩開發板的入門模組之一。網路上有不少文章和 sample code，不過大部分都是直接教你要怎麼呼叫 library 的 API 來控制模組，沒有說明 API 具體的運作流程和為什麼要這樣寫 code，因此就花了點時間整理相關 IC controller 的 datasheet 及 sample code 的對應關係，希望能讓入門玩家可以了解 sample code 實際上是如何操作 LCD 模組來實現字元顯示的目的。&lt;/p&gt;
&lt;h2 id="lcd-2004"&gt;LCD 2004&lt;/h2&gt;
&lt;p&gt;首先，研究 LCD 2004 的 datasheet 來了解如何正確驅動此裝置。以我手邊的模組為例，此 LCD 模組的 IC controller 為 SPLC780D1 或是其他相同規格的 controller，所以也參考 SPLC780D1 的 datasheet，以獲得更完整的控制資訊。&lt;/p&gt;</description></item><item><title>Run Go applications on Raspberry Pi Pico using TinyGo</title><link>https://yushuanhsieh.github.io/posts/2021-10-01-raspi_pico_tinygo/</link><pubDate>Fri, 01 Oct 2021 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2021-10-01-raspi_pico_tinygo/</guid><description>&lt;p&gt;&lt;a href="https://github.com/tinygo-org/tinygo"&gt;TinyGo - Go compiler for small places.&lt;/a&gt; TinyGo 自 2019 年正式公開以來，就逐漸受到關注，尤其是 Google 在 2019 年 &lt;a href="https://go.dev/blog/10years"&gt;10 years of Go&lt;/a&gt; 也有特別提到 Go 原本將目標放在網路或是雲端等應用程式，不過未來期望能夠更廣泛地應用在 microcontroller 上。在近期 TinyGo 開始支援 Raspberry Pi Pico，再加上 TinyGo 架構也逐漸成熟，因此就來試用看看。&lt;/p&gt;
&lt;h2 id="run-applications-on-raspberry-pi-pico"&gt;Run applications on Raspberry Pi Pico&lt;/h2&gt;
&lt;p&gt;在分析 TinyGo 如何編譯適合跑在 Raspberry Pi Pico 的 Go program 之前，先來複習如何讓 user application 在 Raspberry Pi Pico (以下皆簡稱為 Pico) 上執行。在 Pico 進入 user application 的 entry point 之前，會有幾個前置流程，包含：&lt;/p&gt;</description></item><item><title>Boot Flow of Raspberry Pi Pico</title><link>https://yushuanhsieh.github.io/posts/2021-06-19-pico-memory/</link><pubDate>Wed, 30 Jun 2021 08:00:00 +0800</pubDate><guid>https://yushuanhsieh.github.io/posts/2021-06-19-pico-memory/</guid><description>&lt;p&gt;之前 blog 文章有提到 &lt;a href="https://yushuanhsieh.github.io/post/2021-05-23-lab4-multiprocessor/"&gt;JOS 作業系統初始化流程&lt;/a&gt;，包含 x86_64 架構下 muticore 喚醒過程等。而剛好前陣子入手採用 ARM Cortex-M0+ CPU 的 Raspberry Pi Pico 開發板，因此就研究了一下 Raspberry Pi 為 Pico 開發板所撰寫的 bootrom、memory map 和 layout 等。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（以下的 boot flow 是指開發板上電後，硬體完成 hardware controlled boot sequence ，從 processor controlled boot sequence 開始，更多說明可以參考 &lt;a href="https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf"&gt;datasheet:2.7. Boot Sequence&lt;/a&gt;）&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>