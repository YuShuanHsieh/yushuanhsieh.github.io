<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A technical blog about software engineering, system design, and modern development practices."><meta name=author content="Cherie Hsieh"><title>Web — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771486583"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Web</h1></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2021-01-15>Jan 15, 2021</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-01-15-security_module/>Security model of password managers</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>這篇算是接續上次 Meetup 分享會的內容，由於有人提出 password manager 的相關疑問，覺得會不會因為使用 password manager 導致所有隱私資料被看光。與其猜測，不如來看看他們所提出的 security 方案，這篇以 1password 為例，整理其中 security white paper 所提到的保存資料方式，來檢視是不是能夠防止資料被盜取。</p><h2 id=master-password--secret-key--vault>Master Password / Secret Key / Vault</h2><p>在說明 security model 之前，要先了解幾個基本的要素：</p><ol><li>Master password (your password)</li><li>Secret key (account + 26 bytes random data)</li><li>Vault (sensitive data)</li></ol><p><img src=/posts/password_1.png alt=password_1></p></p></article><article class=post-list-item><div class=post-meta><time datetime=2020-12-23>Dec 23, 2020</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-12-23-web_auth/>GDG Hsinchu 12 月 Meetup - Improve Your Web Authentication Security</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>12 月份完成好幾項目標，其中一項就是催生 GDG Hsinchu 12 月份的 Meetup 線下聚會。這次活動跟著 Google 在 12 月時舉辦的 Chrome Dev Summit 2020 一同推出，取自 CDS 中的部分 SMS-OTP 內容，並結合既有的 password-based authentication 與未來有可能普及的 FIDO 2 認證機制，整理出一份 Web Authentication Security 的技術分享。其中對我來說，比較有趣的地方在於理解機制的實現原理，包含資料溝通和驗證，以及可能會產生的安全問題。其實標準規範對於開發者來說相當重要，透過分析 protocol 的行為，可以讓開發者在開發整合性功能的時候，更清楚這些 library 要在什麼時機點使用，以及為什麼要使用這些 functions，這也是我每次進行技術分享時，最希望能夠帶給與會者的內容。</p><p><img src=/posts/gdg_meetup.jpg alt="GDG Hsinchu 202012"></p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-06-14>Jun 14, 2019</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-06-15-side-project/>Side Project for daily study trello</a></h2><p class=post-list-summary><p>![study]({{ site.url }}/assets/images/side-project.png)</p><h2 id=前言>前言</h2><p>用 Trello 紀錄自己的每日學習進度也好一陣子了，雖然 Trello board 搭配 plugin <code>Calendar</code> 很好用，但是卻有資訊分散在各張卡的問題。因此為了便於在月末寫當月學習報告，以及整理所有曾經讀過的 article/post link，就開發了一個小工具 <code>trello-transform</code> 來從 trello cards 中擷取資訊。其實這個 side project 寫了有一段時間了，之前曾經立志要寫一個有前後端的小網站，這樣不會寫 code 的人也可以使用，但是後來就有點擱置了 XD 原因是我把這個功能寫成一個小框架，以因應每個人紀錄習慣不同，不過這樣的調整就需要會寫一點 code 並知道如何修改，對於不會寫 code 的人來說，可能便利性就沒這麼高。另外就是寫成網頁反而不利於我寫 blog，基於這個 side project 本來就是希望先滿足自己需求，因此後來目標就改成就先以 cli tool 實作為主。</p><p>現在這個 side project 成為我每個月必使用的工具，用來擷取學習日誌和 links，除了寫 blog 之外，後續還可以很方便地回顧之前看過的文章，可以說是目前寫過最實用的 project XD </p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-06-14>Jun 14, 2019</time>
<span class=reading-time>12 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-06-22-tail-recuriosn-optimization/>Tail Recursion in Go</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>最近在實驗效能分析時，有使用到 Tail Recursion 寫法，因此也好奇在 Go 中是否有跟 C 一樣進行 Tail Recursion optimization 優化。在文章中，首先會用 C asm 來說明 tail call optimization，接著 dump Go asm code 來觀察結果。</p><h2 id=tail-call>Tail Call</h2><p>在說明 Tail Recursion Optimization 之前，先來說說 <a href=https://en.wikipedia.org/wiki/Tail_call>Tail Call</a>。 Tail Call 概念很簡單，就是在 function 的最後語句執行另一個 function call。</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#cf222e>int</span> <span style=color:#6639ba>search</span><span style=color:#1f2328>(</span><span style=color:#cf222e>int</span> data<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>  <span style=color:#cf222e>return</span> <span style=color:#6639ba>advanced_search</span><span style=color:#1f2328>(</span>data<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><p>要注意的是， <code>Tail Call</code> 意指最後的行為只允許使用 function call，所以以下的寫法就不是 <code>Tail Call</code>，因為它需要先進行 <code>2 * 1 + funcB(a-1)</code> 的運算，才能返回。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-06-04>Jun 4, 2019</time>
<span class=reading-time>8 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-06-04-study-201906/>2019/05月份自我學習回顧</a></h2><p class=post-list-summary><p>![study]({{ site.url }}/assets/images/study-201906.png)</p><h2 id=前言>前言</h2><p>五月的時候，團隊來了一位經驗豐富的瑞典人，而剛好有這個機會跟他合作，除了跟他練練英文口說能力之外，順便學習一下他的程式經驗。瑞典人是一位懂很多層面的工程師，從韌體到 Web Front-end 都有實務經驗，而且為人也不錯，會很認真地看每個 Pull Request，並給予架構上或是程式寫法上的回饋，能有這樣的同事真的很開心，即使在當個碼農趕專案，也會覺得從中學習到不少。</p><p>五月份確實蠻忙的，因此在中旬的時候，一度對於下班學習覺得有點力不從心，但靜下心來思考後，發現其實只是因為自己上班全程精神專注，導致下了班會不想去進修，進而逐漸拉長滑手機和躺在床上發呆的時間。於是，在察覺到自己有這個狀況之後，就開始明確訂出每日學習目標，之前都是很隨興地安排，不會強迫自己要唸到怎樣的進度，不過如果開始怠惰的話，明確的進度才會讓自己不會偷懶，甚至知道哪邊有出現進度落後，而需要做改善。</p><p>在經過這樣小調整之後，學習的動力又回來了，因此在五月下旬時候又恢復到每天都有進度，而不是像中旬一樣，讀個三四天就想休息一天。</p><h2 id=學習回顧>學習回顧</h2><p>五月份學習以<strong>離散數學</strong>和 <strong>Linux</strong> 為主，離散數學除了看韓永楷教授的線上課程之外，還有買一本離散數學課本來練習習題。至於 Linux 目前是以 Jserv 教授的系統核心設計課程為主，不過 Jserv 每次線上課程的內容都蠻多的，所以之後還是需要反覆地看以及實驗，才能夠真正地理解，不然只光看直播其實不太能吸收這麼多資訊。</p><h3 id=離散數學>離散數學</h3><p>目前離散數學課程聽到 13 peg solitaire，進度蠻慢的，不過因為有邊搭配習題練習，所以這個速度也還是能接受。這次學習花比較多時間在實際證明上，因為在學的時候對於證明題總是輕忽，想說考試不太會考，但是現在自主學習沒有考試壓力，再加上理解這些內容，感覺更能讓自己去思考背後原理，每次練習完都蠻有收穫的。</p><h3 id=linux-核心設計>Linux 核心設計</h3><p>本月份有兩次直播課程，包含 <code>Linux 核心設計: 朝向硬即時的核心變革</code> 和 <code>Linux 核心設計: 檔案系統概念及實作手法</code>，線上講座內容都很多而且也比較偏理論說明，所以上完後一定要再花時間去實作和實驗，才能"大略略"了解這個功能在 Linux Kernel 的作用。不過因為要看的東西太多了，所以先從檔案系統開始實驗， Real-Time 部分預計在六月會再重新複習一次。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-05-04>May 4, 2019</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-05-04-study-201904/>2019/04月份自我學習回顧</a></h2><p class=post-list-summary><p>![study]({{ site.url }}/assets/images/golang.jpg)</p><h2 id=前言>前言</h2><p>不知不覺又過了一個月了，本來想說一週要產出一篇文章，結果發現技術文章真的蠻容易難產的，主要原因是我希望能盡可能地從根本去探討這些技術背後運作模式和原理，因此會花費大量時間在整理內容和實驗上。不過部分原因也可能是因為資歷不夠，所以這些內容要思考很久，才會下筆去寫，希望之後慢慢熟稔之後可以加快產出速度。</p><p>上個月曾經提到，我會開始複習大學 CS 基礎課程，因為工作後會隨著時間漸漸地把這些基礎原理忘掉，所以這個月就從離散數學開始看起。說到數學，我覺得現在的我把數學當作一種訓練自己思考邏輯的方式，雖然他對我來說真的有點挑戰性，但是在了解這些數學是如何解出最終解的過程中，其實蠻有樂趣，會讓我很訝異原來可以透過這樣子的方式去找答案。當然我在大學時期也很討厭上課，之所有會有這樣體悟，真的是要等待我出社會累積經歷後，才會認知到這樣邏輯訓練很有助於工作效率。</p><p>除了念書之外，4月份我也去擔任志工協助 Golang Taipei 的擺攤宣傳。在參加活動上我是超級菜逼八，不過真的蠻有意思，可以認識到不同社群的人，能夠互相交流。雖然目前因為工作關係定居在新竹，但還是希望自己能夠多多參與這樣的活動，看看別人如何推廣技術社群也是一種學習！</p><h2 id=學習回顧>學習回顧</h2><p>本月份學習其實蠻雜的，包含 C、Linux、離散數學、還有一些 Go。之所以會這麼雜，是因為我四月份的上班時間都是在寫 Go 和研讀相關文章，我希望在下班時間可以學一點理論知識，會讓我覺得不這麼像碼農。有些人會來信問我，學習這麼發散，那不就等於什麼都不會？但我認為不是這樣子的，每個技術其實背後原理都是互相關聯，而且最重要的是必須讓自己在腦內建立起關鍵字，讓自己在需要這類知識時，可以快速反應到該如何去找相關知識，以及可以聯想到關聯的應用技術，這樣在解決問題時就會快上許多。</p><p>還有另一個原因是，因為專案上使用到 Cgo ，就很自然地想要看一下 C 語言 XD</p><h2 id=學習日誌>學習日誌</h2><p>4月份有 5 天沒有唸書，因為去參加活動，還有氣管過敏有點變嚴重，不知道是不是換季關係 (?)</p><ul><li>2019/4/2 - cgo - how it works</li><li>2019/4/2 - 你所不知道的 C 語言：指標篇 (3)</li><li>2019/4/3 - 你所不知道的 C 語言：指標篇上 - (4)</li><li>2019/4/4 - 你所不知道的 C 語言：指標篇 (下) -1</li><li>2019/4/4 - gRPC - The process of Dial()</li><li>2019/4/5 - gRPC - Name Resolver & Load-Balancer</li><li>2019/4/6 - New Post - gRPC Client 與 Server 連線流程</li><li>2019/4/7 - 你所不知道的 C 語言：指標篇 (下) - 2</li><li>2019/4/8 - 你所不知道的 C 語言：指標篇 (下) -3</li><li>2019/4/9 - Discrete mathematics - Logical operators_review</li><li>2019/4/10 - Discrete mathematics - Logical operators, Tautology and contradiction & Logical equivalence</li><li>2019/4/11 - Linux 核心設計: 記憶體管理 (直播)</li><li>2019/4/12 - Discrete mathematics - Implication</li><li>2019/4/14 - Linux 核心設計: 記憶體管理 (2)</li><li>2019/4/14 - Golang Weekly Study</li><li>2019/4/15 - Article: Golang Race Detection、The Go Memory Model</li><li>2019/4/15 - Discrete mathematics - Puzzle</li><li>2019/4/16 - 惡血，矽谷獨角獸的醫療騙局</li><li>2019/4/19 - Golang Weekly Study (Advanced Test)</li><li>2019/4/19 - Discrete mathematics - Predicate</li><li>2019/4/20 - cgo compile problems solved (include header, dynamic libs, and uint test with .so)</li><li>2019/4/21 - Discrete mathematics - Quantifiers, propositional function</li><li>2019/4/22 - 你所不知道的C語言: Stream I/O, EOF 和例外處理</li><li>2019/4/25 - Discrete mathematics - functional examples</li><li>2019/4/26 - Golang project refactor (enhance concurrency part)</li><li>2019/4/27 - Dig into Cgo process and overhead</li><li>2019/4/28 - dotGo 2019 video</li><li>2019/4/28 - Cgo dump pre-compile files</li><li>2019/4/29 - GopherChina - Go concurrency in practice</li><li>2019/4/30 - Discrete mathematics - Mathematical arguments and functional proposition with De Morgen&rsquo;s Law</li></ul><h2 id=articles>Articles</h2><ul><li><a href=https://github.com/grpc/grpc/blob/master/doc/naming.md>gRPC Name Resolution</a></li><li><a href=https://github.com/grpc/grpc/blob/master/doc/load-balancing.md>Load Balance</a></li><li><a href=https://yushuanhsieh.github.io/Web/gRPC-Dial>gRPC Client 與 Server 連線流程</a></li><li><a href=http://www.catb.org/esr/structure-packing/#_padding>The Lost Art of Structure Packing</a></li><li><a href=https://scene-si.org/2019/04/15/next-level-go-testing/>Next level Go testing</a></li></ul></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-04-05>Apr 5, 2019</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-04-05-grpc-dial/>grpc-go source code trace - gRPC client 與 server 建立連線過程</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>其實一開始的目的是想要研究 gRPC 的 retry 機制，不過在了解 retry 之前勢必要先說明整個 gRPC client 與 server 建立連線的過程，因此就先用 source code trace 的方式簡單說明在呼叫 <code>grpc.Dial</code> 後所執行的連線流程，包含 gRPC 實現 load-balancing 的機制。</p><h2 id=packages>packages</h2><p>grpc-go v1.19.1</p><h2 id=grpcdial-的背後>grpc.Dial 的背後</h2><p>以下是 client 向 server 連線的基本方式。</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#1f2328>conn</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>err</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#1f2328>grpc</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Dial</span><span style=color:#1f2328>(</span><span style=color:#1f2328>serverIpAddress</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>grpc</span><span style=color:#1f2328>.</span><span style=color:#6639ba>WithInsecure</span><span style=color:#1f2328>())</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#cf222e>func</span><span style=color:#fff> </span><span style=color:#6639ba>Dial</span><span style=color:#1f2328>(</span><span style=color:#1f2328>target</span><span style=color:#fff> </span><span style=color:#cf222e>string</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>opts</span><span style=color:#fff> </span><span style=color:#0550ae>...</span><span style=color:#1f2328>DialOption</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span><span style=color:#1f2328>ClientConn</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#cf222e>error</span><span style=color:#1f2328>)</span><span style=color:#fff> </span><span style=color:#1f2328>{</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>  </span><span style=color:#cf222e>return</span><span style=color:#fff> </span><span style=color:#6639ba>DialContext</span><span style=color:#1f2328>(</span><span style=color:#1f2328>context</span><span style=color:#1f2328>.</span><span style=color:#6639ba>Background</span><span style=color:#1f2328>(),</span><span style=color:#fff> </span><span style=color:#1f2328>target</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#1f2328>opts</span><span style=color:#0550ae>...</span><span style=color:#1f2328>)</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span></code></pre></td></tr></table></div></div><p>首先， Client 需要透過 <strong>Name Resolver</strong> 解析 Dial 中的 <code>target string</code> 來取得 Server 正確的 IP Addresses 和 port，以利後續建立 connection。例如使用 DNS Name Resolver，就可以透過 <code>conn, err := grpc.Dial("dns:///your.target.name:8888")</code> 這種 Domain name 的方式來發送 RPCs。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-04-03>Apr 3, 2019</time>
<span class=reading-time>5 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-04-04-study-201903/>2019/03月份自我學習回顧</a></h2><p class=post-list-summary><p>![study]({{ site.url }}/assets/images/golang-meetup.jpeg)</p><h2 id=前言>前言</h2><p>最近這一個月工作慢慢步上軌道，心情有比較踏實些。剛開始來的時候，實在不太確定自己能幫上什麼忙，不過這個月漸漸地有任務可以做，並且也和其他組員一起合作開發，感覺在團隊中可以發揮自己的價值:) 另外，這個月比較大的轉變是完全負責 back-end ，之前還想說可能會接觸到 React ，所以花了一些時間在看 React 原理，不過目前確定會都以 Go 和 Device application 開發為主，因此後續就會把學習重心放在 Back-end。話雖如此，自己還是有加入公司的 front-end 學習群，跟著裡面的大神們一起念 React Core ，畢竟過去一年蠻大比例是使用 JavaScript 開發，要放棄也是蠻可惜的。</p><h2 id=學習回顧>學習回顧</h2><h3 id=go>Go</h3><p>這次很難得地可以參加Go Taipei 社群，分享使用 Go 的開發經驗，過程中花蠻多時間在整理簡報，除了擷取 Practical Go 中實際碰過的案例，也找了些其他跟專案維護相關的文章一並分享。原本以為應該不會太難的，沒想到實際整理起來卻花了快一個禮拜的時間，自己也從各種 references 中發掘更多討論相關議題的文章，收穫良多。在實際分享過後，反而會更積極地參加活動，因為這些分享都是工程師利用私下時間來整理的，如果能踴躍支持，就是給予他們最大的鼓勵吧XD</p><p>另外，由於專案中使用到 gRPC ，所以也花了時間在這部分的 source code 研究，特別是在 client retry 部分，想了解在不使用 iinterceptor 的情況下，能不能滿足目前需要 retry 的場景。此外還有 Http 這些標準 package 的複習等，尤其是公司蠻重視 test 這塊，所以也花時間在看 Httptest 和 Httptrace 等。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-03-14>Mar 14, 2019</time>
<span class=reading-time>8 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-03-14-http-trace/>Golang - Request test using net/http/httptrace</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>在撰寫 HTTP request test 測試程式時，除了測試 response 結果是否如預期之外，我們還需要知道過程中需要耗費多少時間（request latency）。市面上有一些 libraries (e.g <code>opencensus</code>) 能提供相關的 HTTP 事件 trace，不過仔細看會發現他們大多也是整合 golang 本身提供的 <code>httptrace</code> 來實現追蹤功能，因此我們就直接來了解 <code>httptrace</code> 的運作原理和應用方式，再結合 <code>http/httptest</code>，讓 handler test 更完整。</p><h2 id=request-處理流程>Request 處理流程</h2><p>在說明 <code>httptrace</code> 之前，由於 request test 中是藉由 http package 來發起的 ，所以先來了解一下 golang 中，透過 <code>http</code> package 的 client 處理 http request 的流程。</p></p></article><article class=post-list-item><div class=post-meta><time datetime=2019-03-10>Mar 10, 2019</time>
<span class=reading-time>5 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2019-03-10-functional-options/>Functional options pattern in GO</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>之所以使用 <code>Functional options</code> 的契機，是因為用到 gRPC 的 New Server API，發現他是用 <code>functional options</code> 來讓使用者調整 Server 預設配置，這樣的作法不但兼具了擴充性和可用性，也能避免一些使用者誤用。而除了看 source code 來學習如何實作之外，也找起相關文章，進而發現原來早在 2014 年就有人發表過類似教學文，實在是太孤陋寡聞了～</p><p>![study-2019-02]({{ site.url }}/assets/images/functional-options.png)</p><p>趁著這次機會，把相關文章的重點整理出來，讓大家在寫類似 API 時，也能做個參考。</p><h2 id=self-referential-functions>Self-Referential Functions</h2><p>首先要提到的是由 <code>Rob Pike</code> 所整理出 <code>self-referential functions</code> 的<a href=https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html>文章</a>，此 Pattern 方式可用於:</p><ol><li>有效地處理繁多且複雜的 setting options</li><li>需要保留之前所設定的 option</li></ol><p>以下為文章中的實作例子：</p></p></article></div><ul class="pagination pagination-default"><li class="page-item disabled"><a aria-disabled=true aria-label=First class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Previous class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a aria-current=page aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/categories/web/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/categories/web/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/categories/web/page/2/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/categories/web/page/3/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>