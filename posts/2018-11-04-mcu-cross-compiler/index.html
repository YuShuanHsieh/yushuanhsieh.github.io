<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A technical blog about software engineering, system design, and modern development practices."><meta name=author content="Cherie Hsieh"><title>Microprocessor System Lab. - Cross Compiler — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771496292"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><article class=single-post><header class=post-header><h1 class=post-title>Microprocessor System Lab. - Cross Compiler</h1><div class=post-meta><time datetime=2018-11-04>November 4, 2018</time>
<span class=separator>·</span>
<span class=reading-time>5 min read</span></div><div class=post-categories><a href=https://yushuanhsieh.github.io/categories/other/>Other</a></div></header><div class=post-content><h2 id=前言>前言</h2><p>其實整個課程已經看完了，只是因為寫 blog 需要準備很多資料，畢竟有些部分老師快速帶過，所以生產文章的速度遠不及看課程速度XD 這次要說的是 Cross Compiler，因為如果是安裝像是 <code>SW4STM32</code> IDE，它所有 cross compiler 設定都已經備妥妥了，使用者只要按一個蟲蟲鍵便能快速 Debugger，不過實際上它背後執行許多程序，只是因為都被自動配置好了，因此使用者不太需要去處理這些額外的環境設定。</p><h2 id=cross-compiler>Cross compiler</h2><p>當我們在開發 Embedded software 時，通常情況下，都是在自己所使用、性能比較好的 host PC 進行程式碼編寫和 compile，接著把 compile 過後的執行檔燒在開發板上（畢竟開發板的執行效率不如自己手上的電腦好，如果直接使用開發板來 compile，會 compile 到天荒地老吧）。</p><p>不過，大部分人使用的電腦都是 x86 系列，如果直接在電腦上使用一般 compiler，就只會編出僅供 x86 辨識的執行檔，而想要 compile 出其他 CPU 可以辨識的執行檔，就必須透過 <strong>cross compiler</strong> 的協助才行。</p><p><img src=http://1.bp.blogspot.com/-vcFB6vudSTs/UvIFwsB5zMI/AAAAAAAADw8/sIuPoi6Fkes/s1600/toolchain_definintion.bmp alt=img>
<em>source: <a href=http://abhishekmourya.blogspot.com/2014/02/cross-compiling-toolchain.html>http://abhishekmourya.blogspot.com/2014/02/cross-compiling-toolchain.html</a></em></p><p>至於 cross compiler 取得方式也很簡單，像是使用 ARM 系列 CPU，就能直接在官網上下載到專屬的 <a href=https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads>GNU Embedded Toolchain for Arm</a> 來幫你處理這些 cross compile 問題。</p><p>如果使用 IDE，我們也可以查看他的 builder 設定，來得知 IDE 是怎樣設定 cross compiler 。以 <code>SW4STM32</code> 為例，打開它 project setting，並點選 C/C++ builder，就會看到相關的 compiler 設置。</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -DSTM32 -DSTM32F4 -DSTM32F401RETx -DNUCLEO_F401RE -DDEBUG -O0 -g3 -Wall -fmessage-length=0 -ffunction-sections -c
</span></span></code></pre></td></tr></table></div></div><h3 id=what-is-arm-none-eabi-->What is arm-none-eabi- ?</h3><p>從上面可以發現，同樣是使用 gcc，上面的 gcc 加了 <code>arm-none-eabi-</code> 這個 prefix，那麼 <code>arm-none-eabi-</code> 是什麼呢？簡單來說， cross compiler 有通俗的命名原則。</p><p><strong>arch-vendor-(os-)abi</strong></p><ul><li>arch is for architecture: arm, mips, x86, i686&mldr;</li><li>vendor is tool chain supplier: apple, Codesourcery, Linux, os is for operating system: linux, none (bare metal)</li><li>abi is for application binary interface convention: eabi(embedded application binary interface), gnueabi, gnueabihf</li></ul><p>如此一來，只要看到 cross compiler 的命名方式，很快就可以知道它 compile 出來的檔案適合用在怎樣的平台上。</p><p>舉例來說，我的 STM32F4 project 最基本就包含 <code>arm-none-eabi-gcc</code> 和 <code>arm-none-eabi-as</code> (for assembly language)，讓我可以編寫 C 和 assembly 兩種語言的程式碼。</p><h2 id=config-linker-script-with-cross-compiler>Config Linker script with cross compiler</h2><p>通常我們在把 C code file compile 成可以被執行的 binary 執行檔，會經過以下流程，其中很重要的是，我們必須把所需的 object files 透過 Linker 連結在一起，才能 compile 出完整的執行檔。所以在使用 cross compiler 時，也必須告知其 linker file。</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -T&#34;/my-project/MCU/mcu-example/LinkerScript.ld&#34; -Wl,-Map=output.map -Wl,--gc-sections -lm
</span></span></code></pre></td></tr></table></div></div><p><img src=https://images.slideplayer.com/27/9191896/slides/slide_6.jpg alt=imgs></p><h2 id=結論>結論</h2><p>Cross compiler 可以讓我們在開發不同平台的軟體時， compile 出其對應的執行檔案。除了上面例子有提到的 <code>arm-none-eabi-gcc</code>，還有其他像是 <code>arm-none-linux-gnueabi-gcc</code> 這些不同 compiler，如果之後接觸到 Embedded Linux System，就必須換用到適合 Linux 的 cross compiler 了！</p><h2 id=reference>Reference</h2><ul><li><a href=https://slideplayer.com/slide/9191896/>https://slideplayer.com/slide/9191896/</a></li><li><a href="http://ocw.nctu.edu.tw/course_detail-v.php?bgid=9&amp;gid=0&amp;nid=246&amp;v5=1_MWy4ReHIE">http://ocw.nctu.edu.tw/course_detail-v.php?bgid=9&amp;gid=0&amp;nid=246&amp;v5=1_MWy4ReHIE</a></li></ul></div><footer class=post-footer><div class=post-nav><a href=https://yushuanhsieh.github.io/posts/2018-11-02-aug-study/ class="post-nav-link prev"><span class=label>← Previous</span>
<span class=title>10月份自我學習日誌回顧</span>
</a><a href=https://yushuanhsieh.github.io/posts/2018-11-15-node-red/ class="post-nav-link next"><span class=label>Next →</span>
<span class=title>Node-Red - Node 坑坑紀錄</span></a></div></footer></article></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>