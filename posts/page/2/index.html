<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Technical articles about software engineering, system design, and development practices."><meta name=author content="Cherie Hsieh"><title>Posts — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771496292"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Posts</h1><p class=page-description>Technical articles about software engineering, system design, and development practices.</p></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2022-02-26>Feb 26, 2022</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2022-02-26-crypto-subsystem_1/>Crypto Subsystem of Linux Kernel - Asynchronous & Synchronous</a></h2><p class=post-list-summary><p>在 crypto subsystem 中，crypto API 分成 asynchronous (異步) 和 synchronous (同步) 兩種機制。</p><p>最早版本的 crypto API 其實只有 synchronous crypto API，但隨著要處理的資料量增加，運算和資料傳輸時間也可能大幅拉長，此時 synchronous crypto API 有可能讓處理流程陷入較長時間的等待，因此後來引入了 asynchronous crypto API，供使用者依據自己的使用場景來選擇適合的機制。</p><p>而 asynchronous 與 synchronous crypto API 在命名設計上有所區別，asynchronous 會在前綴多加一個 <code>a</code> 字，反之 synchronous 則是 <code>s</code> 字，以 hash 為例：</p></p><a href=https://yushuanhsieh.github.io/posts/2022-02-26-crypto-subsystem_1/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2022-02-15>Feb 15, 2022</time>
<span class=reading-time>11 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2022-02-15-linux-kernel-crypto/>Crypto Subsystem of Linux Kernel - Overview</a></h2><p class=post-list-summary><p>介紹由應用層所發出的 crypto(cryptography) request，透過 system call 將 request 傳送到 Linux kernel 端，並經由 crypto subsystem 將 request 轉發給硬體算法引擎 (hardware crypto engine) 的流程。</p><h2 id=overview>Overview</h2><p>Crypto subsystem 是 Linux 系統中負責處理 crypto request 的子系統，除了包含流程控制機制之外，另一個重要特色就是提供演算法實作的抽象層，讓各家廠商能夠依據需求去客製化實作方式。其中一個常見例子就是廠商在硬體架構中加入用以加速特定演算法運算效率的硬體算法引擎，並且透過 crypto subsystem 將驅動硬體算法引擎的流程整合進 Linux 系統中，供其他 kernel module 或是應用層使用。</p><p>以下以 openSSL library 如何將 crypto request 傳送到 kernel crypto subsystem 為例子：</p></p><a href=https://yushuanhsieh.github.io/posts/2022-02-15-linux-kernel-crypto/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2022-01-28>Jan 28, 2022</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2022-01-28-tfm_boot/>Secure Boot using Trusted Firmware-M</a></h2><p class=post-list-summary><p><a href=https://www.trustedfirmware.org/about/>Trusted Firmware</a> 是 ARM 基於自家具有 <a href=https://developer.arm.com/ip-products/security-ip/trustzone>TrustZone</a> 功能的處理器所實作的開源程式，其主要目的是讓相關廠商可以更快速地將 TrustZone 架構性的整合到產品當中，此外同時也是廠商要取得 <a href=https://www.psacertified.org/>ARM PSA certification</a> 認證的參考資源。由於近年來資安議題逐漸受到重視，愈來愈多客戶開始尋找結合硬體實現的安全方案，因此就有這個機會了解一下 Trusted Firmware 軟體架構及其中的 secure boot 流程。Trusted Firmware 包含了幾個專案，這篇文章是以其中的 <a href=https://www.trustedfirmware.org/projects/tf-m/>Trusted Firmware-M(Arm v7-M & v8-M)</a> 為例，如果是 A 系列的處理器則有 Trusted Firmware-A 可供參考。</p><h2 id=overview>Overview</h2><p>首先先來看 Trusted Firmware-M 的架構：
<img src=https://developer.arm.com/-/media/Arm%20Developer%20Community/Images/Block%20Diagrams/TrustedFirmware-M-block-diagram.png alt>
<em>image resource: developer.arm.com</em></p><p>最主要的概念是透過硬體控制 (記憶體位置區間、權限控管等）的方式，將原先的執行環境切割成 <code>secure processing enviroment(SPE)</code> 和 <code>non secure processing enviroment(NSPE)</code> 兩個執行環境。SPE 主要是提供需要安全保護的服務，例如韌體更新、加解密；而 NSPE 則是一般使用者執行應用程式的環境。如果在 NSPE 中執行的應用程式使用到 secure 層級的服務，則需要透過特定 API 來呼叫（這個概念類似作業系統的 user-space 和 kernel-space 會透過 system call 來溝通），這樣可以限制 NSPE 的操作權限，避免重要機密資源外洩。</p></p><a href=https://yushuanhsieh.github.io/posts/2022-01-28-tfm_boot/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2022-01-01>Jan 1, 2022</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2022-01-01-review-2021/>2021 年度回顧</a></h2><p class=post-list-summary><p>2022 新的一年到來，就來回顧一下去年所經歷的重要事情，並且規劃 2022 年的大方向。</p><h2 id=工作>工作</h2><h3 id=回顧>回顧</h3><p>2021 年工作最大的轉變就是從內部 IT 部門轉換到產品向 firmware 部門。在 2020 年時我有約略提到自己在 IT 部門面臨到不適應問題，當時是覺得要把重心放在研究跟公司產品相關 security 專業知識，也確實在轉換心境後有了不少收穫。不過在年中時很榮幸地從 IT 部門正式轉調到 firmware 部門，參與了幾個客戶專案，也主動進行產品 firmware 架構重構發想和討論，更具體的對公司產品做出貢獻，整體來說很有成就感。</p><p>在工作中學習確實比自己進修還要有幫助，不過之前進修中所累積的知識也讓我能在工作迅速上手，並且更快速地找到該改善的方向和問題點。當然 IP 廠 firmware 相關的工作，除了提供公版 library 之外，另一個很重要的項目就是 IP 驗證，這個項目相較於開發工作其實較為繁瑣，而且如果很單純的做驗證，會覺得這個任務十分打雜，就是協助硬體測試而已。因此我在做驗證的時候，會從市場角度去思考客戶需要這功能的目的性，以及如何改善 firmware 架構來讓驗證流程自動化。假如這些功能真的只能手動，那就思考該怎樣減少手動的步驟，盡可能利用軟體工程來協助加快驗證的速度。我覺得工作中難免會遇到大家都不想做的打雜工作，但是這些打雜工作卻又是整個專案中不可或缺的一環，代表還是有其重要性，因此盡量從中找到可以學習的地方，能夠提高工作時的成就感。</p><h3 id=展望>展望</h3><p>2022 年工作中的展望，就是將目前 firmware 架構調整成更成熟且具彈性的架構，並且完善驗證自動化流程。在 2021 年的專案中了解到組織和客戶的需求，並且也知道目前的 firmware 具體的改善方向。所以 2022 年的目標就是可以解決這些痛點，使得整個 firmware 開發與 IP 驗證流程更佳順暢，讓自己有更多時間可以著墨在產業相關的專業知識學習和系統層面的架構思考。</p></p><a href=https://yushuanhsieh.github.io/posts/2022-01-01-review-2021/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-12-29>Dec 29, 2021</time>
<span class=reading-time>12 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-12-29-golang-slice-append/>Golang slice append 實作細節</a></h2><p class=post-list-summary><p>用 Golang 刷 leetcode 題目時，如果不太清楚 Golang slice 與相關 function 的運作原理，很容易踩到坑，尤其是使用其他高階語言的開發者，剛轉換到 Golang 時會覺得為什麼同樣的程式邏輯，但是出來的結果卻不一樣。因此本篇簡單說明 Golang 最常使用到的 slice append function 運作原理，並且使用 objdump 來觀察記憶體操作狀況。</p><h2 id=slice-internal>Slice internal</h2><p>首先推薦先閱讀 Golang blog <a href=https://go.dev/blog/slices-intro>Go Slices: usage and internals</a>，雖然距離文章發布的日期已久遠，但是 slice internal 結構還是可以參考。文中很重要的一個概念是：<strong>A slice is a descriptor of an array segment.</strong>， 雖然我們使用 slice 方式很像 array ，但實際上 slice 是一個 descriptor struct ，其中會有一個 array pointer 指向真正存放數值的 array 中。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-12-29-golang-slice-append/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-12-10>Dec 10, 2021</time>
<span class=reading-time>11 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-12-10-lcd-2004/>LCD 2004 module with Rasp Pico</a></h2><p class=post-list-summary><p>LCD 2004/1602 顯示模組應該是玩開發板的入門模組之一。網路上有不少文章和 sample code，不過大部分都是直接教你要怎麼呼叫 library 的 API 來控制模組，沒有說明 API 具體的運作流程和為什麼要這樣寫 code，因此就花了點時間整理相關 IC controller 的 datasheet 及 sample code 的對應關係，希望能讓入門玩家可以了解 sample code 實際上是如何操作 LCD 模組來實現字元顯示的目的。</p><h2 id=lcd-2004>LCD 2004</h2><p>首先，研究 LCD 2004 的 datasheet 來了解如何正確驅動此裝置。以我手邊的模組為例，此 LCD 模組的 IC controller 為 SPLC780D1 或是其他相同規格的 controller，所以也參考 SPLC780D1 的 datasheet，以獲得更完整的控制資訊。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-12-10-lcd-2004/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-12-01>Dec 1, 2021</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-12-01-status-update/>12/1 生日快樂</a></h2><p class=post-list-summary><p>12/1 是我生日 :) 近期完成了一些事情，像是決定研究所論文題目、回歸 Golang meetup 進行分享、參與 2021 年度 DevFest 盛會，並做了人生中比較完整的一次健康檢查。</p><p>前幾年生日時，總是會立定幾項進修目標，一步一步督促自己完成，過程中也相當有成就感。不過今年在體驗健檢和周遭所發生的事物後，覺得進修固然重要，不過身體健康才是能持續進修的關鍵。所以今年生日的目標，就是專注在研究所課業和工作就好，在身心健康和行有餘力的情況下，再來考慮實作個人 side project 和修習其他專業知識。</p><h2 id=golang-meetup>Golang Meetup</h2><p>這次在年底有幸地參與了 11 月的 Golang Meetup。其實已經好一陣子都沒有寫 Go 了，都是以 C/C++ 為主，不過剛好有這機會玩起 TinyGo project，因此這次 Meetup 就針對 TinyGo compile 流程和 TinyGo 不同開發板的配置機制來介紹。其中這流程涉及到我們所謂的 porting 流程，所以也從中學習到不少。</p><p><img src=/posts/golang_2021.jpg alt></p><h2 id=devfest-2021>DevFest 2021</h2><p>Golang Meetup 結束後，緊接著就是 11/13 新竹和台中 GDG DevFest 聯合場。老實說這是我第一次參加 DevFest，所以看到專業的錄音器材很驚訝，覺得之前我的線上分享都不認真，因為如果收音品質不好的話，基本上參與的人也會覺得很吃力～告誡自己下次如果有想要繼續辦線上活動，一定要準備好基本的設備再去參加。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-12-01-status-update/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-10-01>Oct 1, 2021</time>
<span class=reading-time>16 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-10-01-raspi_pico_tinygo/>Run Go applications on Raspberry Pi Pico using TinyGo</a></h2><p class=post-list-summary><p><a href=https://github.com/tinygo-org/tinygo>TinyGo - Go compiler for small places.</a> TinyGo 自 2019 年正式公開以來，就逐漸受到關注，尤其是 Google 在 2019 年 <a href=https://go.dev/blog/10years>10 years of Go</a> 也有特別提到 Go 原本將目標放在網路或是雲端等應用程式，不過未來期望能夠更廣泛地應用在 microcontroller 上。在近期 TinyGo 開始支援 Raspberry Pi Pico，再加上 TinyGo 架構也逐漸成熟，因此就來試用看看。</p><h2 id=run-applications-on-raspberry-pi-pico>Run applications on Raspberry Pi Pico</h2><p>在分析 TinyGo 如何編譯適合跑在 Raspberry Pi Pico 的 Go program 之前，先來複習如何讓 user application 在 Raspberry Pi Pico (以下皆簡稱為 Pico) 上執行。在 Pico 進入 user application 的 entry point 之前，會有幾個前置流程，包含：</p></p><a href=https://yushuanhsieh.github.io/posts/2021-10-01-raspi_pico_tinygo/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-09-03>Sep 3, 2021</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-09-04-tsmc-sre-interview/>台積電 SRE 面試心得</a></h2><p class=post-list-summary><p>又好一陣子沒有更新 blog 了，先簡單聊一下概況。五月底的時候有一次轉換到新公司的機會，不過和既有公司商量後，雙方同意內轉到研發單位的軟韌體部門，因此就繼續留在現在的公司。也因為剛轉換部門，很多新的流程和產品需要學習，就暫時把心力都放在跟公司產品相關的技術進修，期望自己能快一點跟上腳步。目前轉到新部門約過了三個月的時間，一切適應良好，工作任務也可以在期限內順利完成，同事相處也都很融洽，過的很開心。</p><p>在七月中的時候，接到台積電的 SRE 主動面試邀約，直到最近才結束整個面試流程。整個面試流程覺得收穫良多，所以在此簡單記錄一下。面試一共會有專業項目三關 + 人資一關，由於主管希望面試者能有較充足的準備，因此專業項目每一關的間隔時間預定是兩個禮拜，如果有需求需要加快面試速度也是可以調整時程。現在疫情期間，除了測驗要去廠區之外，其他面試一率都是視訊面試。</p><h2 id=第一關專長簡介和專業問題-60-分鐘>第一關：專長簡介和專業問題 (60 分鐘)</h2><p>一面的流程會分成四個部分：</p><ol><li>(主管) 部門介紹</li><li>(主管) 整體面試流程介紹</li><li>面試者專長簡介和簡答題</li><li>Q & A</li></ol><p>主管在介紹完部門和面試流程後，會請面試者介紹自己擅長的領域。這邊比較特別的是，主管有說明已完整看過我的履歷，所以希望我能只就自己專業領域和擅長方向介紹即可，而他會根據我所說的內容進行提問。而我回答我比較擅長的方向是：Golang 和 Web backend。</p><p>主管提問內容包含：</p><ol><li>sorting algorithm / BST / stack / queue / binary tree / hash map 具體實作和相關 time complexity</li><li>HTTP protocol 流程和 package format</li><li>cookie</li><li>Linux 環境的操作 (包含查看記憶體、 network package、service port、process)</li></ol><p>自認在 Linux 這一塊沒有回答的很好，知道用哪些工具去查看，但是問到更細節的部分就不太了解。不過主管說這樣問是想了解面試者的程度在哪裡，所以不會就說不會就好。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-09-04-tsmc-sre-interview/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-06-30>Jun 30, 2021</time>
<span class=reading-time>7 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-06-19-pico-memory/>Boot Flow of Raspberry Pi Pico</a></h2><p class=post-list-summary><p>之前 blog 文章有提到 <a href=https://yushuanhsieh.github.io/post/2021-05-23-lab4-multiprocessor/>JOS 作業系統初始化流程</a>，包含 x86_64 架構下 muticore 喚醒過程等。而剛好前陣子入手採用 ARM Cortex-M0+ CPU 的 Raspberry Pi Pico 開發板，因此就研究了一下 Raspberry Pi 為 Pico 開發板所撰寫的 bootrom、memory map 和 layout 等。</p><p><em>（以下的 boot flow 是指開發板上電後，硬體完成 hardware controlled boot sequence ，從 processor controlled boot sequence 開始，更多說明可以參考 <a href=https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf>datasheet:2.7. Boot Sequence</a>）</em></p></p><a href=https://yushuanhsieh.github.io/posts/2021-06-19-pico-memory/ class=read-more>Read more →</a></article></div><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label="Page 1" class=page-link role=button>1</a></li><li class="page-item active"><a aria-current=page aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/posts/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/posts/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/posts/page/3/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/11/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>