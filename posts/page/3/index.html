<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Technical articles about software engineering, system design, and development practices."><meta name=author content="Cherie Hsieh"><title>Posts — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771486583"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Posts</h1><p class=page-description>Technical articles about software engineering, system design, and development practices.</p></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2021-05-07>May 7, 2021</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-04-23-life/>CSE 506 Lab 4 - Multiprocessor Support</a></h2><p class=post-list-summary><p>Lab 4 包含三個部分，其中 A 部分介紹 x86 架構的 multiprocessor 啟動與初始化流程，並且實作簡易的 round-robin process scheduling。而我認為從 bootstrap processor 啟動並初始化，到透過 bootstrap processor 把其他的 processor 啟動的整個過程相當重要，可以讓新手更具體地知道 multiprocessor 的運作方式。</p><p>JOS 實作 intel <a href=https://en.wikipedia.org/wiki/MultiProcessor_Specification>MultiProcessor Specification(MPS)</a> 標準，在看 source code 的時候，搭配這個文件來看會更加理解每項步驟的用意。</p><p><strong>Note:</strong>
Multiprocessor 架構會依據設計而有所不同，以下所提到的內容皆以 x86 MPS 制定的規格為主。</p><h2 id=multiprocessor-architecture>Multiprocessor Architecture</h2><p>Multiprocessor 架構下，每個 processor 有各自的 L1 cache 和 APIC，並且透過 ICC (interrupt controller communications) bus 進行溝通。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-04-23-life/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-04-24>Apr 24, 2021</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-04-24-go-calling-convention/>Switch to a register-based calling convention for Go functions</a></h2><p class=post-list-summary><p>自己對於 memory layout 相關議題都蠻感興趣的，而這次 Go 1.17 有一項效能改善的 proposal: <a href=https://go.googlesource.com/proposal/+/master/design/40724-register-calling.md><strong>switch to a register-based calling convention for Go functions</strong></a> 剛好跟 memory 有相關，因此就看了一下 proposal 文件介紹，不但複習了在計算機架構中曾接觸到的 calling convention 知識，也對於 Go 內部機制有更多認識。</p><h3 id=application-binary-interface-abi>Application Binary Interface (ABI)</h3><p>在談 calling convention 之前，先來談 ABI。Calling convention 是 <a href=https://en.wikipedia.org/wiki/Application_binary_interface>application binary interface (ABI)</a> 的一部分，而定義 ABI 最主要的目的是建立應用程式與其他應用程式或是與作業系統服務之間低階溝通方式 (依賴 machine code) ，讓應用程式能夠在特定的環境下正確執行。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-04-24-go-calling-convention/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-04-22>Apr 22, 2021</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-04-22-life/>近況雜談</a></h2><p class=post-list-summary><p>一個月沒有更新 blog，因為遇上了一些事情要處理，再加上剛好正值工作轉換之際，以及面對研究所考試和 paper study，所以就停筆了，不過還是有在持續地進修，學習的包含 security 和 system design 部分，並且每天刷 leetcode 訓練邏輯能力防失智。</p><p>前陣子面試的時候，發現自己有很多不足之處，導致自己無法在面試時有比較好的表現，尤其對於一些久未使用的 protocol，關於它的特性和流程就不是這麼熟悉。檢討自己面試問題，主要是因為自己是佛系面試派，認為平常應該要持續地累積實力，因此不太會因為面試而刻意準備，就像是我去考研究所在職專班ㄧ樣，完全沒有看考古題就去考試了，如果沒有上就代表我實力還不夠。</p><p>但是這種想法用在面試上就蠻糟的，尤其現在面試的公司多是一線廠，光是競爭者的實力就很優異，再加上面試時可能會緊張，平常實力再打折，導致整體表現就是比其他 candidate 遜色。另外，現在面試蠻多會遇到 medium level 的演算法測驗，如果準備不夠的話，有時候會突然邏輯失常，無法發揮正常表現，這也是我應該要改進的地方。</p><p>總結來說，就是面試心態不夠慎重。1-3年內經驗的菜鳥工程師時期可能還可以靠平常實力去面試，不過當要去面試資深工程師時，就必須把過往專案接觸過的理論知識重新複習一遍，避免因為時間久遠而無法回答精確。</p><p>基於這些原因，最近也花時間整理專案上會用到的 protocol 與各種 service 運作原理，如果很不幸又需要面試，還可以拿出來快速複習一番 (但我現在不想再換工作 XD，覺得一些產業知識還是要累積起來才行)</p><p>閒聊完了，最近會開始整理文章並發文，同時還要準備 COSCUP 內容，希望能快點有靈感～</p></p><a href=https://yushuanhsieh.github.io/posts/2021-04-22-life/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-02-18>Feb 18, 2021</time>
<span class=reading-time>11 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-02-18-l1-cache-arm/>L1 Cache architecture in ARM</a></h2><p class=post-list-summary><h1 id=l1-cache-architecture>L1 Cache architecture</h1><p>之所以會看這個主題，是因為網路黑貓(Champ Yen)大大分享 ARM 從 virtual cache 轉到 physical cache 的利弊。雖然曾經從書上看過兩者差異性，不過沒搭配硬體架構，總覺得沒有好好了解。因此這篇整理了 ARM Programmer’s Guide 的內容，並透過實際例子來探討 VIVT (virtual indexed vritual tagged)、VIPT(virtual indexed physical tagged)、PIPT(physical indexed physical tagged) 的差異性。</p><h2 id=virtually-addressed-caches-vivt>Virtually Addressed Caches (VIVT)</h2><p>十多年前的 ARM Processor L1 cache 採用 VIVT cache 架構，在當時的 ARM architecture reference 5.5.1 節有提及主要的原因：</p></p><a href=https://yushuanhsieh.github.io/posts/2021-02-18-l1-cache-arm/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-02-10>Feb 10, 2021</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-02-11-th02-driver/>TH02 sensor device driver</a></h2><p class=post-list-summary><p>馬上就要過年了，最近在整理物品的時候，突然找到一年前為了玩板子而亂買的 Grove sensor，回想當時雖然對於韌體很感興趣，不過由於工作關係，因此把大部分進修時間都花在 Web 議題，沒能完成 sensor 韌體，留下一個遺憾。而既然這次被我找出來，近期工作又是都以 FPGA 板子居多，對於相關概念已有基本認知，覺得是時候把它實作出來，了結一年前給自己的課題。</p><p><img src=/posts/i2c-driver_4.png alt></p><h2 id=硬體>硬體</h2><ul><li>Grove Temperature&amp;Humidity Sensor (High-Accuracy & Mini)</li><li>Raspberry Pi 3 Model B (Linux kernel 5.4.x)</li></ul><p><img src=/posts/i2c-driver_5.png alt></p><h2 id=技術>技術</h2><ul><li>I2C linux driver</li><li>linux Industrial I/O subsystem</li><li>device tree</li></ul><p>由於買的 sensor 有支援 I2C bus protocol，因此這次實作的 driver 就會基於 I2C driver 架構上實作。搭配 iio (Industrial I/O) subsystem 來讓 user space 能夠透過 file system 來讀取溫度和濕度。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-02-11-th02-driver/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-01-26>Jan 26, 2021</time>
<span class=reading-time>12 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-01-26-lab3_2/>CSE 506 Lab 3 - Interrupts</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>2020 年過去了，因為年底各種考試和工作， Lab3 下半部份延遲到現在才完成。雖然拖蠻久的，但是往好的方向看就是有在持續進行下去，沒有放棄就是好結局！最近心境上有蠻多變化的，其中本來對於目前工作內容很疑惑，覺得跟純軟生活落差太大，但是在工作中慢慢地發現自己對於 security 領域的認知嚴重不足，如果能好好學習 security 相關知識，對於自己和未來發展還是挺有幫助的，結合 security 與 embedded or cloud 去發展，是一個有趣又有挑戰性的目標，因此目前就朝著這方向努力，希望今年可以在 COSCUP 分享 security 相關議題。</p><h2 id=lab-3-interrupts>Lab 3 Interrupts</h2><p>在開始實作 interrupt 之前，先結合上一篇 <a href=https://yushuanhsieh.github.io/post/2020-11-25-lab3_1/>CSE 506 Lab 3 - User Environments(Processes)</a> environment(process) 的觀念，綜觀一下 interrupt 結合 environment context switch 的 interrupt handle 過程。</p></p><a href=https://yushuanhsieh.github.io/posts/2021-01-26-lab3_2/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2021-01-15>Jan 15, 2021</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2021-01-15-security_module/>Security model of password managers</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>這篇算是接續上次 Meetup 分享會的內容，由於有人提出 password manager 的相關疑問，覺得會不會因為使用 password manager 導致所有隱私資料被看光。與其猜測，不如來看看他們所提出的 security 方案，這篇以 1password 為例，整理其中 security white paper 所提到的保存資料方式，來檢視是不是能夠防止資料被盜取。</p><h2 id=master-password--secret-key--vault>Master Password / Secret Key / Vault</h2><p>在說明 security model 之前，要先了解幾個基本的要素：</p><ol><li>Master password (your password)</li><li>Secret key (account + 26 bytes random data)</li><li>Vault (sensitive data)</li></ol><p><img src=/posts/password_1.png alt=password_1></p></p><a href=https://yushuanhsieh.github.io/posts/2021-01-15-security_module/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-12-23>Dec 23, 2020</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-12-23-web_auth/>GDG Hsinchu 12 月 Meetup - Improve Your Web Authentication Security</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>12 月份完成好幾項目標，其中一項就是催生 GDG Hsinchu 12 月份的 Meetup 線下聚會。這次活動跟著 Google 在 12 月時舉辦的 Chrome Dev Summit 2020 一同推出，取自 CDS 中的部分 SMS-OTP 內容，並結合既有的 password-based authentication 與未來有可能普及的 FIDO 2 認證機制，整理出一份 Web Authentication Security 的技術分享。其中對我來說，比較有趣的地方在於理解機制的實現原理，包含資料溝通和驗證，以及可能會產生的安全問題。其實標準規範對於開發者來說相當重要，透過分析 protocol 的行為，可以讓開發者在開發整合性功能的時候，更清楚這些 library 要在什麼時機點使用，以及為什麼要使用這些 functions，這也是我每次進行技術分享時，最希望能夠帶給與會者的內容。</p><p><img src=/posts/gdg_meetup.jpg alt="GDG Hsinchu 202012"></p></p><a href=https://yushuanhsieh.github.io/posts/2020-12-23-web_auth/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-11-25>Nov 25, 2020</time>
<span class=reading-time>14 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-11-25-lab3_1/>CSE 506 Lab 3 - User Environments(Processes)</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>之前在辦活動的時候，得知有朋友在 follow 我的 Blog ，真是讓我非常訝異，因為我一直是默默撰寫文章，而且雖然我有參與 Golang 和 GDG 社群，但是我寫的內容很常都跟 Golang 和 Google 技術沒什麼太大關係 XD 非常感謝各位的觀看，之前有近兩個月都沒更新，感覺有點罪惡，以後會盡量定期更新的。</p><p>目前除了自修 CSE 506 課程之外，還有學習 RISC-V instruction 以及 pipeline，因為過往經驗都是看 x86_64 instruction 居多，現在改看 RISC-V 還蠻不習慣的。另外就是還想學用 Rust 寫 kernel module，目前趨勢是有些 Kernel developers 嘗試將 Rust code 結合進 Linux kernel 中，再加上 Rust 的發展也蠻成熟，是時候抽空來學習一下。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-11-25-lab3_1/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-11-15>Nov 15, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-11-15-lab2_2/>CSE 506 Lab2 - Memory Management and Virtual Memory Mapping</a></h2><p class=post-list-summary><h2 id=閒聊>閒聊</h2><p>上次寫完 Lab 2 source code study 之後，一晃眼就過了近兩個月。中間被各種事物攔截，加上剛好有些機遇和機會，因此挪了一些時間去準備，等事情有比較明朗後再跟大家分享。此外，學校也開學了，這學期修了偏硬體架構的課程，包含 RISC-V 和架構效能分析等，單智君教授的教學內容很好，聲音也很溫柔，非常喜歡這位教授的課程。</p><p>這時間還遇上 Macbook 螢幕完全無法顯示的意外，經由朋友提醒，2016 年產的 13 吋 Macbook Pro 有螢幕背光災情，Apple 有提供免費召回維修的服務，因此花了一些時間送修。而 Apple 的服務也還不錯，整個螢幕換新，看來又可以撐好一陣子了 &lt;3</p><h2 id=lab-2>Lab 2</h2><p><a href=https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/lab2.html>實驗說明文件</a></p><h2 id=part-1-physical-page-management>Part 1: Physical Page Management</h2><p>Part 1 是實作 physical memory allocator。在 <a href=https://yushuanhsieh.github.io/post/2020-09-12-lab2-1/>CSE 506 Lab2 - E820 Memory Map & Page Translation (1)</a> 可以看到系統在執行 kernel code 前，有先在 bootstrap 階段建立 page translation 所需的 pml4 table，以確保 kernel code 可以正確地被執行，不過在 kernel code 運行階段，我們需要建立新的 pml4 table ，來讓我們可以有更多控制權。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-11-15-lab2_2/ class=read-more>Read more →</a></article></div><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/page/2/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/posts/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class="page-item active"><a aria-current=page aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/posts/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/posts/page/4/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/11/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>