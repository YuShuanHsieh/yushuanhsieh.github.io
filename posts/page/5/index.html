<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Technical articles about software engineering, system design, and development practices."><meta name=author content="Cherie Hsieh"><title>Posts — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771486583"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Posts</h1><p class=page-description>Technical articles about software engineering, system design, and development practices.</p></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2020-05-28>May 28, 2020</time>
<span class=reading-time>8 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-05-28-ingress-gce/>Introduction to ingress-gce controller</a></h2><p class=post-list-summary><p>如果想要在 Google Cloud Platform 的 GKE 上使用 Ingress 功能，最簡單的方式就是用 GKE 本身預設提供的 <code>ingress-gce</code> controller。不過不知道大家在設定 ingress yaml 的時候，有沒有留意到 <code>ingress-gce</code> 規定 service type 只能是 <code>NodePort</code>，但是 <code>ingress-nginx</code> 卻沒有這種限制呢？</p><p>本篇文章會從 Google Cloud Platform 所提供的 load balancer 服務開始說明，並且結合 <code>ingress-gce</code> controller，讓大家瞭解兩者的運作方式和限制原因。</p><h2 id=google-cloud-platform-load-balancer>Google Cloud Platform Load Balancer</h2><p>首先來說明 Google Cloud Platform 的 external load balancer 的運作流程：</p></p><a href=https://yushuanhsieh.github.io/posts/2020-05-28-ingress-gce/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-05-19>May 19, 2020</time>
<span class=reading-time>4 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-05-19-transfer.sh/>Side Project - Transfer.sh</a></h2><p class=post-list-summary><p>在 <a href=https://yushuanhsieh.github.io/post/2020-04-15-transfer-sh-refactor/>Trace transfer.sh open project</a> 有提到我目前正在調整 <a href=https://github.com/dutchcoders/transfer.sh>transfer.sh</a> 這個 open source project，把它修改成內部所需要的一個 service，而之前已經改得差不多了，所以簡單地來介紹一下修改了哪些內容：</p><h2 id=需求>需求</h2><ol><li>每個 download request 能依需求驗證 IP address 和 user account / password</li><li>能使用外部 service 來驗證 user account</li><li>需能支援 curl cmd tool</li><li>k8s deployment</li></ol><h2 id=修改項目>修改項目</h2><h3 id=1-middleware-chain>1. Middleware Chain</h3><p>根據需求 1，在 <code>getHandler</code> 前加入 middleware chain，其中包含：</p></p><a href=https://yushuanhsieh.github.io/posts/2020-05-19-transfer.sh/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-29>Apr 29, 2020</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-29-hugo-symlinks/>Side Project - Symlink Generator for Multi-lang Hugo Site</a></h2><p class=post-list-summary><p>在 <a href=https://yushuanhsieh.github.io/post/2020-04-07-hugo-merge/>Multilingual Mode in Hugo</a> 這篇文章中有提到目前使用 Hugo site generator 產生 multi-lang site 的問題，使用者必須要為每個語言都建立一個檔案，才不會造成最後在產生網站後，發生某一個語言的頁面遺失問題。（例如，使用者一定要建立 <code>about.md</code>, <code>about.tw.md</code>，這樣當瀏覽者在選擇中文語言的網站時，才會顯示出 about 頁面）。這樣其實會造成不少困擾，因為不是每個語言都可以這麼即時的被翻譯完成，但我們又不希望有頁面遺失，因此需要透過一些方式來解決這個問題。</p><p>而其中一個方法就是建立一個 <code>symbolic link</code>，當某個語言還沒被翻譯時，就建立一個 symbolic link 來代表這個檔案，然後實際檔案則指向預設語言的檔案。</p><h2 id=hugo-langs-symlink><a href=https://github.com/YuShuanHsieh/hugo-langs-symlink>hugo langs symlink</a></h2><p>因此，side project <a href=https://github.com/YuShuanHsieh/hugo-langs-symlink>github.com/YuShuanHsieh/hugo-langs-symlink</a> 就是為了這個目的而誕生的，用我熟悉的 Go 語言來編寫，使用者可以透過參數來決定要建立 <code>symbolic link</code> 的語言和檔案對象。Project 簡單地提供 <code>create</code> 和 <code>remove</code> 兩個 sub command ，這樣用戶就能直接在 local 端操作和刪除 <code>symbolic link</code>，避免產生過多的 <code>symbolic link</code> 而影響到 git commit。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-04-29-hugo-symlinks/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-22>Apr 22, 2020</time>
<span class=reading-time>11 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-22-discourse-deployment/>Discourse Forums Deployment</a></h2><p class=post-list-summary><p>這兩天在試著部署 Discourse －目前主流的 forum open porject。雖然它有 cloud 版本可以用，不過因為基於一些因素，我們打算先自行部署，給團隊成員實際試用測試過後，再來看是否要使用官方提供的 Cloud 付費版本。而在部署的過程中發現蠻多問題的，所以也一併記錄下來，給想要自行部署的人參考。</p><h2 id=discourse-container>Discourse Container</h2><p>首先在 Discourse container 部份，我們選擇由 bitnami 所維護的 <a href=https://hub.docker.com/r/bitnami/discourse/>bitnami/discourse</a> 版本，原因是它提供相對完整的 configuration 和流程，事後證明這個選擇也是對的，因為我有嘗試使用 Discourse 所提供的 container 來部署，結果根本是場災難，畢竟官方所提供的 container 本來就不適合用在自行部署，除了流程複雜之外，size 也大許多 (2.5GB)。</p><h3 id=version>Version</h3><p>Discourse 版本部分，目前 (2020/04) 官方是 <code>2.5.0 beta</code>，而 bitnami/discourse 則是 <code>2.4.1</code> 也就是官方所提供的最新穩定版本，因此不會有太大的版本落差。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-04-22-discourse-deployment/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-15>Apr 15, 2020</time>
<span class=reading-time>8 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-15-transfer-sh-refactor/>Trace transfer.sh open project</a></h2><p class=post-list-summary><p>因為工作需求，需要一個透過 cli 就可以 upload 和 download 的工具，剛好 open project <code>transfer.sh</code> 有提供類似的功能，不過我們有額外的需求，包含每個 request 都要能 fiter IP 和執行 HTTP Basic Auth 驗證，因此就有這個機會來分析一下 <code>transfer.sh</code> source code 並且後續可以針對我們需求來修改！</p><h2 id=source-code-分析>Source code 分析</h2><h3 id=http-router>HTTP Router</h3><p>首先來看 <code>transfer.sh</code> 的 source code，這個 project 其實程式碼蠻少的，所以大概花個幾個小時就可以大致了解運作方式。<code>transfer.sh</code> 是一個簡單的 Web server，其 path router 是使用 <code>gorilla/mux</code>，雖然 <code>gorilla/mux</code> 的 path search 是 slice 設計， route 效率不比 radix tree router 效能好，不過因為這個 Web server 的 path 也不多，所以就還可以接受。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-04-15-transfer-sh-refactor/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-04-07>Apr 7, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-04-07-hugo-merge/>Multilingual Mode in Hugo</a></h2><p class=post-list-summary><p>紀錄用 Hugo site generator 建立多語言網站時所遇到的問題，與過程中相關的學習內容，包含 Hugo render 過程、source code trace 等。</p><h2 id=預備知識>預備知識</h2><h3 id=the-flow-of-hugo-render>The flow of Hugo Render</h3><p>Hugo 是一個 Site Generator，那他是怎麼產出這些 static html 的呢？首先程式會先遍歷在 <code>content</code> folder 底下所有的 folder 和 file，並且組成一個 <code>contentTree</code> (題外話， contentTree 是採用 radix 資料結構)。然後再把這些 content node 根據 node type (e.g. type 可能是 sections or taxonomies) 去對應到 <code>layout</code> folder 內的 template，接著 render 出最後的 html 頁面。(也可參閱 <a href=https://github.com/gohugoio/hugo/blob/master/hugolib/site.go#L78>hugolib/site.go</a> 由 Hugo 開發者所寫的簡易流程)</p></p><a href=https://yushuanhsieh.github.io/posts/2020-04-07-hugo-merge/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-03-31>Mar 31, 2020</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-03-31-march/>三月起，在竹北定區生活</a></h2><p class=post-list-summary><p>三月一整月都在非常忙碌的情況下度過。</p><h2 id=搬家>搬家</h2><p>在經過漫長地油漆、裝系統櫃、打掃等流程，我在竹北的新房終於裝潢完成，因此在三月初的時候就很匆忙地把租屋處退掉，並且搬來新家住。本來租屋只有十坪大小，現在換成近三十坪的生活空間，突然有點不太習慣，需要清潔的區塊也變大不少，也開始體悟掃地機器人的重要性。由於當初在買房子的時候，有點太快做決定，因此一直很擔心新家會不會有什麼不好的地方，不過現在搬進來幾個禮拜，覺得一切都還蠻美好的，樓上樓下鄰居都不會吵鬧，社區環境安靜單純，戶數不多所以整潔還不錯，主委也非常盡責。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-03-31-march/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-02-24>Feb 24, 2020</time>
<span class=reading-time>2 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-02-24-february/>2月雜談</a></h2><p class=post-list-summary><p>最近一個月發生了一些事情，導致又一陣子沒有更新技術文章或是讀書日誌。</p><p>一月底的時候在工作上發生了一件事情，讓我突然間深深陷入負面情緒中。其實我早在事情發生之前是有所選擇的，我可以選擇穩定或是挑戰，而我在那時候選擇了挑戰，即使這挑戰讓我付出蠻多代價，包含家人的不諒解、長距離通勤等，我在事情沒發生之前都覺得這一切代價都算值得。</p><p>在事情發生後，我其實剛開始的幾天是非常沮喪的，我覺得我那時候做了錯的選擇，才會讓自己陷入進退兩難的局面。我本來就是轉職人生，這樣的背景讓我更難坦然地面對現實，因為我要付出的成本比團隊工程師們都要高。</p><p>不過在冷靜之後，我開始回想，我在這段短暫旅程中，是否有達到我當初的目的。</p><p>我有幸跟強者同事一起工作
有很好的主管讓我 work from home
我接觸到我之前不會碰到的 cloud service 和相關 infrastructure
我開始念起 AWS 和 GCP 並希望可以考過證照</p><p>如果當初我沒有選擇這條路，會有現在的我嗎？我覺得應該很難。</p><p>我學到了很多東西，即使結果可能不如當初想的一樣，但我還是在這過程中學到不少技能和回憶。</p><p>如果再問我一次，我會說我不後悔當初的選擇。</p><p>我不太確定未來會怎樣發展，但是我會繼續地把新學到的技能，一路地深入堅持下去。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-02-24-february/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-01-21>Jan 21, 2020</time>
<span class=reading-time>13 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-01-21-golang-router/>Go HTTP Routers - Chi/Echo/Gin/gorilla mux 實作細節與比較</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>之前做 API server，制定 route path 時有遇到一些問題，於是就順手看了幾個 HTTP router / web framework 的 router 部分實作方式，並且記錄下來，提供給大家做個參考。</p><h2 id=問題>問題</h2><p>需要加入</p><ol><li>/stations/instances</li><li>/stations/{id}</li></ol><p>這兩個 path 對應到不同的 handlers。</p><h2 id=chi>Chi</h2><p>package <code>github.com/go-chi/chi</code></p><p>知名 HTTP router library <code>chi</code>，其輕量、快速、handler 使用原生 <code>net/http</code> struct，都是不錯的優勢。和多數主流的 HTTP router 相似，chi 的 router 是採用 <a href=https://en.wikipedia.org/wiki/Radix_tree>radix tree</a> 結構，比較特別的是 chi 將 node type 分成四種：</p></p><a href=https://yushuanhsieh.github.io/posts/2020-01-21-golang-router/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2020-01-19>Jan 19, 2020</time>
<span class=reading-time>16 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2020-01-19-memory-allocator-implicit-free-list/>Implement Memory Allocator - Implicit Free List</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>由<a href=https://yushuanhsieh.github.io/c/memory%20allocator/stack-memory-allocator/>前篇</a>文章可以知道，使用 stack data structure 是最簡單的 memory allocator 入門寫法，但是卻會造成一些問題，例如不能任意順序 free 等。既然如此，我們就換成 list 來實作 memory allocator，解決使用 stack 實作的問題。</p><p>除了實作之外，也會討論到幾個實作 allocator 上遇到的問題，例如 sbrk，以及 minimum alignment。</p><h2 id=memory-allocator-要素>Memory allocator 要素</h2><p>在實作之前，先歸納一下 allocator 需求。 <a href=https://www.tenlong.com.tw/products/9780134092669>Computer Systems(book)</a> 與 <a href=https://my.eng.utah.edu/~cs4400/>CS 4400 – Computer Systems</a> 說明幾個 allocator 要素，包含：</p><ol><li>Handling arbitrary request sequences</li><li>Aligning blocks (8 bytes on 32-bit and 16 bytes on 64-bit)</li><li>Not modifying allocated blocks (compaction is not allowed)</li><li>How does <code>free</code> know an allocated block’s size?</li><li>How is unallocated space represented?</li><li>How do we keep track of free blocks?</li><li>How do we choose an appropriate free block?</li></ol><p>依照上列條件，可以知道 stack 形態的 allocator 其實並不能滿足基本 allocator 需求(例如：arbitrary request sequences)，因此後續在實作 implicit free list 的時候，也會根據上列來一一檢視是否有達成需求。</p></p><a href=https://yushuanhsieh.github.io/posts/2020-01-19-memory-allocator-implicit-free-list/ class=read-more>Read more →</a></article></div><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/page/4/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class="page-item active"><a aria-current=page aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/posts/page/6/ aria-label="Page 6" class=page-link role=button>6</a></li><li class=page-item><a href=/posts/page/7/ aria-label="Page 7" class=page-link role=button>7</a></li><li class=page-item><a href=/posts/page/6/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/11/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>