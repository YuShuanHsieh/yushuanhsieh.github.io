<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Technical articles about software engineering, system design, and development practices."><meta name=author content="Cherie Hsieh"><title>Posts — Cherie's Tech Blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link rel=stylesheet href="/css/style.css?v=1771496292"></head><body><header class=site-header><div class=header-inner><a href=https://yushuanhsieh.github.io/ class=site-logo><span class=logo-icon>⟨/⟩</span>
<span class=logo-text>Cherie's Tech Blog</span></a><nav class=site-nav><a href=/ class=nav-link>Home</a>
<a href=/posts/ class=nav-link>Posts</a>
<a href=/categories/ class=nav-link>Categories</a>
<a href=/about/ class=nav-link>About</a></nav><button class=mobile-menu-toggle aria-label="Toggle menu">
<span></span>
<span></span>
<span></span></button></div></header><main class=site-main><section class=post-list-page><header class=page-header><h1 class=page-title>Posts</h1><p class=page-description>Technical articles about software engineering, system design, and development practices.</p></header><div class=post-list><article class=post-list-item><div class=post-meta><time datetime=2018-11-02>Nov 2, 2018</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-11-02-aug-study/>10月份自我學習日誌回顧</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>這次十月份的學習方向和預設有點不太一樣，主要是因為某天在因緣際會之下，接觸到交大開放式課程 <code>微處理機系統實驗 Microprocessor System Lab.</code>，覺得實在是太有趣了，所以就欲罷不能的聽下去，順便把一些相關教學材料也買齊，好好學一下 MCU 。可以預知，接下來會繼續上曹孝櫟老師的 <code>嵌入式系統設計概論與實作 Introduction to Embedded Systems Design and Implementation</code> ，剛好本身也是在 IOT 產業，每天都要接觸到 Embedded Systems，這老師說的很好，讓我學習到很多 :D</p><h2 id=預設目標>預設目標</h2><ol><li>Protocol proctise MQTT and modbus</li><li>Operating System Book</li><li>Implementation: C (c-example)</li></ol><h2 id=每日學習內容>每日學習內容</h2><ul><li>10/31: Review STM32 Timer Configuration - OSI -> PLL -> SYSCLK, AHB, APB</li><li>10/30: USART - 1</li><li>10/29: LCD lecture - 字形檔 / display mem addr / cg rom / cg ram</li><li>10/28: Implement 7 segment LED and Interrupt and Exception 2</li><li>10/27: Interrupt and Exception 1</li><li>10/26: How to use Advanced Timer and Counter</li><li>10/25: Basic Timer concept and how to calculate correct time period. The concept of general timer and advanced timer</li><li>10/24: Got a board and practice basic I/O output. and blog post.</li><li>10/23: The algorithm of page replacement. Memory - map file (such as 顯示卡)</li><li>10/22: Virtual Memory - Demand Page / GPIO Input setting and DIP Switch</li><li>10/21: STM32 General purpose I/O configuration, memory map</li><li>10/20: Qemu enviorment / ARM STM 32 base assembly language</li><li>10/19: Page Table - Outer table, Hashtable / Modbus slave daemon implement</li><li>10/18: Parse Modbus Slave Data</li><li>10/17: Page Table and Mapping. (Page, Offset, Page Size, Byte Address)</li><li>10/16: Swap (mid-term scheduler) / Memory allocation - page, frame | Modbus slave data format parse</li><li>10/15: Implement sjf scheduler</li><li>10/14 : Process Syncchoronization</li><li>10/13: Implement Hashmap with a effective way / C unit test using Check framework.</li><li>10/12: Process Syncchoronization 204 - 207</li><li>10/11: C Source code trace: How to use & and FNV hash fun. The effective way to create hashmap.</li><li>10/10: EDF scheduling, Share scheduling, Linux CFS scheduling.</li><li>10/9: Protocol packet format study</li><li>10/8: Real-time Process Schedulers / C - How to use define # and ##</li><li>10/7: thread_pool</li><li>10/6: C - pthread / sem_wait / pthread_cond_wait</li><li>10/5: 星期五，休息</li><li>10/4: CPU scheduler concept</li><li>10/3: something you should note about using threads. Signal / thread pools</li><li>10/2: multi thread - thread content, models, and Pthread.</li><li>10/1: <code>RPC</code> concept (book 154 -160) / Linux <code>Netcat</code> / <code>Stub</code> class</li></ul></p><a href=https://yushuanhsieh.github.io/posts/2018-11-02-aug-study/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-10-24>Oct 24, 2018</time>
<span class=reading-time>8 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-10-24-mcu-study-1/>Microprocessor System Lab. - Nucleo-64 development board</a></h2><p class=post-list-summary><h2 id=前言>前言：</h2><p>在英國的時候，學校大多專注在純軟開發課程上，例如敏捷開發(Agile Development), Web Development, database 等。其中有一堂課令我印象深刻，就是用 logic Unit, MUX 零件自組 16 Instruction Processor，然後自己手動按 Clock 去 fetch / execute instrction，透過這樣的學習，讓我更清楚整個電腦實際運作 Code 的流程。</p><p>自從經過這樣的學習後，對於 Processor 總是有種幻想，雖然回到台灣之後都是在做純軟工作，不過還是很希望可以接觸到更多相關知識（在台灣這些都是資工基本課程，可惜我大學是偏資管，並沒有機會能修到這些課）。幸好，在交大課程找到 <code>微處理機系統實驗</code> 和 <code>嵌入式系統設計概論與實作</code> 這兩堂課程，其中<strong>曹孝櫟教授</strong>教的非常詳細又很有重點，讓我瞬間變他的腦粉啊 &lt;3</p><p>由於學的很開心，也收穫很多，就來記錄一下學習過程。</p><h2 id=課程連結>課程連結</h2><ol><li><a href="http://ocw.nctu.edu.tw/course_detail-v.php?bgid=9&amp;gid=0&amp;nid=572&amp;v5=KmvfobI87bA">Lecture03 Overview of STM32 Board/Development Environment</a></li></ol><h2 id=nucleo-64-development-board>Nucleo-64 development board</h2><p>這堂課是使用 <code>Nucleo</code> 系列板子，Processor 是 <code>ARM Cortex-4M</code>，所以就也買了類似的開發板來玩玩。我是從 <a href=https://www.taiwaniot.com.tw/>物聯網科技</a> 這邊買的，寄件速度快，有可以超商取貨，材料種類又多，很推薦這個網站。</p></p><a href=https://yushuanhsieh.github.io/posts/2018-10-24-mcu-study-1/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-10-05>Oct 5, 2018</time>
<span class=reading-time>4 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-10-05-study-9/>9月份自我學習日誌回顧</a></h2><p class=post-list-summary><h2 id=9月份目標>9月份目標</h2><ul><li>把 Effective Go 看完</li><li>複習 JavaScript 概念，釐清各細節</li><li>工作上用到的 Protocol 相關知識</li></ul><h2 id=目標回顧>目標回顧</h2><h3 id=1-把-effective-go-看完>1. 把 Effective Go 看完</h3><p>已看完，印象比較深刻的部分包含：</p><h4 id=the-difference-between><a href=https://golang.org/doc/effective_go.html?#allocation_new>The difference between <code>new</code> and <code>make</code></a></h4><blockquote><p><code>New</code> - It&rsquo;s a built-in function that allocates memory, but unlike its namesakes in some other languages it does not initialize the memory, it only zeros it.</p></p><a href=https://yushuanhsieh.github.io/posts/2018-10-05-study-9/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-09-24>Sep 24, 2018</time>
<span class=reading-time>9 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-09-24-node-js-napi/>Node.js Addons N-API example (v10.11.0)</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>由於專案需要整合 <a href=https://nodered.org/>Node-RED</a> ，我們必須開發自己的 Node 來讓用戶可以直接透過視覺化方式來建立簡單邏輯，又我們的 SDK 是 C 版本，因此有這機會可以接觸 Node.js 所提供的 C/C++ Addons 功能。另外，自己寫 server-side 都是使用 Golang，所以這也是難得的機會可以試試 Node.js。</p><p>目前網路上使用 Node.js <code>N-API v10.x</code> 版本的範例並不多，初期在使用時也因為對於原理不熟悉，因而踩過一些坑，希望這篇文章能講述基本概念，讓其他使用者能避免也踩到相同的坑。</p><h2 id=相關技術>相關技術</h2><ul><li>C</li><li>Node.js N-API 與v8一些原理知識</li><li>JavaScript</li></ul><h2 id=how-cc-addons-work-with-javascript>How C/C++ Addons Work With JavaScript</h2><blockquote><p><strong>C/C++ Addons</strong> Node.js Addons are dynamically-linked shared objects, written in C++, that can be loaded into Node.js using the require() function, and used just as if they were an ordinary Node.js module.</p></p><a href=https://yushuanhsieh.github.io/posts/2018-09-24-node-js-napi/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-09-09>Sep 9, 2018</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-09-09-go-tar-file/>Go - Archive files with archive/tar lib</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>由於專案要提供 API 來讓使用者 export 匯出檔案， 因此需要將所需檔案集結成一個 archive file。這個流程是透過 Go 的標準 lib <code>archive/tar</code> 來處理，以下文章將簡單介紹流程和實作方式，並於最後附上完整程式碼。</p><h2 id=tar>Tar</h2><p><code>tar</code> 在UNIX/Linux系統中是最常見的打包工具，透過 <code>tar</code> 的協助，我們可以把數個檔案打包成一個 <code>&lt;file name>.tar</code> 檔案，以利進行後續處理。</p><p>![Go-Tar-1.png]({{ site.url }}/assets/images/Go-Tar-1.png)</p><h3 id=tar-file-format>tar file format</h3><p><code>.tar</code> 的檔案格式主要是由 <code>file object</code> 和其對應的 <code>header</code> 所組成。 <code>header</code> 裡面包含了一個 file 的 metadata（例如檔案名稱，數據大小等），這樣系統就可以透過 header 去檢測檔案屬性和完整度。</p></p><a href=https://yushuanhsieh.github.io/posts/2018-09-09-go-tar-file/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-08-25>Aug 25, 2018</time>
<span class=reading-time>12 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-08-25-go-google-oauth/>Google Sign-in with OAuth 2.0</a></h2><p class=post-list-summary><h2 id=前言>前言：</h2><p>由於目前專案是以 Embedded System 為主，比較少有機會接入第三方 api 的機會，所以這次 side project 就以 Google Sign-in for Web application with Go 的流程當作練習。由於網路上可以找到很多範例，所以在以下文章中會側重在原理 + 為什麼要這樣做，希望除了寫 code 之外，還能建立起基本概念。</p><h2 id=oauth-20>Oauth 2.0</h2><p>要實作 Google Sign-in 流程之前，不免要來簡單提到 Oauth 2.0。 OAuth 是一個用於授權認證的標準協議(RFC 6749)，與一般網站常用到的個人帳號驗證機制不同的地方是，OAuth 強調<strong>第三方應用程式授權機制</strong>，所以它的內容有明確定義出各角色定義，包含：</p><ul><li>resource owner</li><li>resource server</li><li>client</li><li>authorization server</li></ul><p>以這次要實作的場景為例，使用者要透過 Google 帳號來登入我的網站，這裡 <code>resource owner</code> 是指使用者，<code>client</code> 是指我的網站，<code>resource server</code> 和 <code>authorization server</code> 則都是指 Google 所提供的服務。</p></p><a href=https://yushuanhsieh.github.io/posts/2018-08-25-go-google-oauth/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-08-11>Aug 11, 2018</time>
<span class=reading-time>3 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-08-11-go-fundamental-array/>Go Fundamental - Array</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>最近在學 Go，而之前有一些 C 的基礎，因此在學到 Go 的 Array 時，發現它和 C 的 Array 差異性蠻大的，所以特別記錄下來。</p><h2 id=array>Array</h2><p>Go</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#1f2328>students</span><span style=color:#fff> </span><span style=color:#0550ae>:=</span><span style=color:#fff> </span><span style=color:#1f2328>[</span><span style=color:#0550ae>3</span><span style=color:#1f2328>]</span><span style=color:#cf222e>string</span><span style=color:#1f2328>{</span><span style=color:#0a3069>&#34;student1&#34;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0a3069>&#34;student2&#34;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span><span style=color:#0a3069>&#34;student3&#34;</span><span style=color:#1f2328>}</span><span style=color:#fff>
</span></span></span></code></pre></td></tr></table></div></div><p>C</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#cf222e>char</span> <span style=color:#0550ae>*</span>students<span style=color:#1f2328>[</span><span style=color:#0550ae>3</span><span style=color:#1f2328>]</span> <span style=color:#0550ae>=</span> <span style=color:#1f2328>{</span><span style=color:#0a3069>&#34;student1&#34;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#34;student2&#34;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#34;student3&#34;</span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=gos-arrays-are-values>Go&rsquo;s arrays are values.</h3><p>首先，最大的不同點是： Go 的 Array 是一個 Value，也就是 <code>students</code> 這個 Variable 就代表整個 Array 。反之， C 在宣告 Array 後， <code>students</code> 是代表指向 Array 第一個 element 的 pointer，而不是整個 Array。</p></p><a href=https://yushuanhsieh.github.io/posts/2018-08-11-go-fundamental-array/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-08-05>Aug 5, 2018</time>
<span class=reading-time>11 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-08-05-angular-schematics/>Angular Schematics</a></h2><p class=post-list-summary><h2 id=前言>前言：</h2><p>最近專案需要提供工具讓外部人員一同參與 Web App 的開發，由於我們的 Web App 已經有基本架構和開發方式，為了讓外部人員能夠更方便的 follow 架構，所以就決定使用 Schematics 來創建專屬樣板，讓協作開發人員可以迅速地建立專案用的 component page，然後他們只需要修改部分程式碼即可。</p><h2 id=angular-schematics>Angular Schematics</h2><p>因為我們使用 Angular 框架，所以就使用 Angular Schematics 來建立樣板。Schematics 是一個改善 workflow 的工具，而透過 Angular Schematics ，我們可以模組化地調整專案現有檔案，例如在專案內新增指定檔案，或是修改既有檔案的內容等，減少手動調整 effort 和錯誤發生。</p><p>如同圖片所示，我們使用 Schematics 將要修改的部分（橘色方塊）apply 在 staging area，當所有內容調整完成，再 apply 到既有的專案中。（為什麼要有 staging area，主要是因為
Schematics 中可能有不只一個修改步驟，透過先應用在 staging area ，可以避免中間有錯誤發生，而導致直接影響到既有專案） <img src="https://static1.squarespace.com/static/5618e3e3e4b0b6c3336cd921/t/5b1019b5352f53e4588abea8/1527781833021/GIF1.gif?format=1500w" alt="Schematics are atomic">
Image source：http://recurship.com/blog/2018/5/31/xfvrq9aauqkayhkd4kzp7gsbfg2bfl</p></p><a href=https://yushuanhsieh.github.io/posts/2018-08-05-angular-schematics/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-07-15>Jul 15, 2018</time>
<span class=reading-time>7 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-07-15-redux-anti-pattern/>Redux Anti Pattern</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>這篇文章是基於 <a href=https://blog.mgechev.com/2017/12/07/redux-anti-patterns-race-conditions-state-management-duplication/>Redux Anti-Patterns - Part 1. State Management</a> 所進行的探討，包含在專案內是否有犯類似的錯誤，以及後續該如何改善。文章會結合目前專案所使用的 Redux(ngrx)，並檢視使用 Ngrx 是否能避免這些錯誤發生。</p><h2 id=1-state-duplication>1. State Duplication</h2><h3 id=問題點>問題點</h3><p>錯誤的建立 state 導致 state 內部 property 或是與其他 state 內容重複。文章內以 session 為例子：</p><div class=highlight><div style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-text-size-adjust:none><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#cf222e>interface</span> <span style=color:#1f2328>Store</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>sessions</span>: <span style=color:#cf222e>Session</span><span style=color:#1f2328>[];</span>
</span></span><span style=display:flex><span>  <span style=color:#57606a>/** The currentSession would be a part of sessions*/</span>
</span></span><span style=display:flex><span>  <span style=color:#1f2328>currentSession</span>: <span style=color:#cf222e>Session</span><span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=解決方式>解決方式</h3><p>如上面的例子，將 <code>currentSession</code> 改成 index 檢索，所以我們實際取用資料時，還是使用 <code>sessions</code> 內的資料，而不是複製一份到 currentSession。</p></p><a href=https://yushuanhsieh.github.io/posts/2018-07-15-redux-anti-pattern/ class=read-more>Read more →</a></article><article class=post-list-item><div class=post-meta><time datetime=2018-06-24>Jun 24, 2018</time>
<span class=reading-time>6 min read</span></div><h2 class=post-list-title><a href=https://yushuanhsieh.github.io/posts/2018-06-24-css-typed-om/>CSS Typed Object Model</a></h2><p class=post-list-summary><h2 id=前言>前言</h2><p>Chrome 66 版本全新支援 <code>CSS Typed Object Model</code>，透過這種新型的 CSS Typed OM，可以有效提升使用 JavaScript 操作 CSSOM 屬性的效率。雖然目前僅有 Chrome 支援（ Firefox 據說在努力中， Edge 目前沒下文），不過既然此方式能對網頁呈現效能有所提升，讓開發者和使用者都因此受惠，未來想必會成為主流方式。</p><h2 id=cssom--css-typed-object-model>CSSOM & CSS Typed Object Model</h2><h3 id=cssom>CSSOM</h3><p>傳統的 CSSOM 是使用 string 格式來進行 style 修改或是讀取等行為，當開發者傳遞一個 string 內容給 CSSOM 時，它會再解析 string 成真正需要的數值。這樣一來一往需要蠻大的成本，再加上開發者傳送 string 時不好偵錯，以及不方便開發者進行一些數值的運算等，讓傳統 CSSOM 似乎不太適合樣式操作。</p></p><a href=https://yushuanhsieh.github.io/posts/2018-06-24-css-typed-om/ class=read-more>Read more →</a></article></div><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/page/8/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/page/7/ aria-label="Page 7" class=page-link role=button>7</a></li><li class=page-item><a href=/posts/page/8/ aria-label="Page 8" class=page-link role=button>8</a></li><li class="page-item active"><a aria-current=page aria-label="Page 9" class=page-link role=button>9</a></li><li class=page-item><a href=/posts/page/10/ aria-label="Page 10" class=page-link role=button>10</a></li><li class=page-item><a href=/posts/page/11/ aria-label="Page 11" class=page-link role=button>11</a></li><li class=page-item><a href=/posts/page/10/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/11/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></section></main><footer class=site-footer><div class=footer-inner><p class=footer-copyright>&copy; 2026 Cherie's Tech Blog. All rights reserved.</p><p class=footer-powered>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a></p></div></footer></body></html>